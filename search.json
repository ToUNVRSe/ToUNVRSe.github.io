[{"title":"AGC061 A Long Shuffle","url":"/post/AGC061-A/","content":"题意\r\n给定长度为  的序列满足 ，定义操作 ：\r\nS(l,r)=    if r-l&gt;1        S(l,r-1)        S(l+1,r)    else        swap(a[l],a[r])\r\n求执行  之后的 。\r\n思路\r\n\r\n的递归定义不太本质，不妨直接考虑底层的交换（设 -=\r\n表示相邻两位进行交换），那么 \r\n为：\r\n-= -=\r\n不妨构造 ，过程为：\r\n1,4-= -= -=  -=-=-=1,6-=-= -=-= -=-=  -=-=-=-=  -=-=-=  -=1,8-=  -=  -=  -=-=-=-=-= \r\n我们发现对于 ，因为两次向右位移一位，中间的部分会直接抵消。\r\n显然，这样我们只会交换左奇右偶的位置对，那么这样两次都交换就等于没有交换。\r\n这是一个谢尔宾斯基三角形的标准形式，那么我们可以得到下表（行号为\r\n，右边直接对应交换情况）：\r\n-=-=-=-=  -=-=-=-=-=-=      -=-=-=    -=-=-=  -=  -=  -=-=-=-=-=-=-=-=-=-=              -=-=-=            -=-=-=  -=          -=  -=-=-=-=-=        -=-=-=-=-=      -=      -=      -=-=-=    -=-=    -=-=    -=-=-=  -=  -=  -=  -=  -=  -=  -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\r\n那么显然，我们只要求出 \r\n附近的一次交换即可得解（对于 \r\n为奇数，则可能要两次）。\r\n利用分形的性质，我们定义 \r\n表示这个位置是否需要交换： \r\n\r\n第一行表示 \r\n超出了三角形之外；\r\n第二行表示 \r\n落在了整次幂中（此时整一行为 ）；\r\n第三行表示 \r\n在左半边，此时上面的三角形与当前三角形是一样的，所以向上走；\r\n第四行表示 \r\n在右半边，此时左边的三角形与当前三角形是一样的，所以向左走。\r\n\r\n显然，这是一个 \r\n的过程。\r\n细节上虽然我们定义的三角形是放大了两倍的，但因为这是一个分形，放大两倍还是自己，所以\r\n 无需进行任何处理。\r\n\r\n以上纯纯赛时脑子不好使，实际上  减一之后 。\r\nCODE\r\n因为自己 rating 没到 1200 所以没有写代码。\r\nupd 2023/2/17: 补了。\r\n#include&lt;cstdio&gt;using namespace std;using ll=long long;const int FSIZE=1&lt;&lt;20;ll t,n,k;char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}bool c(ll n,ll k){    --k;--n;    return(k&gt;=0&amp;&amp;(n&amp;k)==k);}void work(){    read(n);read(k);    if(n&amp;1){        if(k&amp;1){            if(c(n-1,k-1)) printf(\"%lld\\n\",k-2);            else if(c(n-1,k)) printf(\"%lld\\n\",k+1);            else printf(\"%lld\\n\",k);        }else{            if(c(n-1,k)){                if(c(n-1,k+1)) printf(\"%lld\\n\",k+2);                else printf(\"%lld\\n\",k+1);            }else printf(\"%lld\\n\",k);        }    }else if(c(n,k)){        if(k&amp;1) printf(\"%lld\\n\",k+1);        else printf(\"%lld\\n\",k-1);    }else printf(\"%lld\\n\",k);}int main(){    fread(BuF,1,FSIZE,stdin);    for(read(t);t--;work());    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Unknown"]},{"title":"AGC027D Modulo Matrix","url":"/post/AT-agc027-D/","content":"题意\r\n构造 \r\n矩阵，元素互不相同且小于 ，所有相邻两个数字的 \r\n相等，且不等于零。\r\n\r\n思路\r\n不妨假定每个数要么大于相邻的四个数，要么小于相邻的四个数。\r\n这样整张图构成一个网状结构：\r\n\r\n\r\n\r\n这样可以使得 ，然后只要蓝色格全部  即可。\r\n这样，我们就需要蓝色格是周围黑色格的 ，接下来只需考虑黑色格如何互不相同并且让蓝色格尽可能小。\r\n可以对于同一斜线上的黑色格赋予同一种质数，由于每个黑色格在两条不同方向的斜线上，这样只需\r\n 的质数就能得到 \r\n的数量，并且这样每个蓝色格周围只会有 \r\n种质数，只需要避免两个方向上最大的质数取  即可保证小于 。\r\nCODE\r\n#include&lt;cstdio&gt;using namespace std;const int N=20010,FSIZE=1&lt;&lt;26;int n,pr[N];bool no[N];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}int main(){    fread(BuF,1,FSIZE,stdin);    read(n);    for(int i=2,cnt=0;cnt&lt;N;++i){        if(!no[i]) pr[cnt++]=i;        for(int j=0;j&lt;cnt&amp;&amp;i*pr[j]&lt;N;++j){            no[i*pr[j]]=1;            if(!(i%pr[j])) break;        }    }    for(int i=1;i&lt;=n;++i,puts(\"\"))        for(int j=1;j&lt;=n;++j)            printf(\"%lld \",(i^j)&amp;1?                (long long)                pr[(i+j-2)&gt;&gt;1]*pr[n+((i-j)&gt;&gt;1)]*                pr[(i+j)&gt;&gt;1]*pr[n+((i-j-2)&gt;&gt;1)]+1:                pr[(i+j-1)&gt;&gt;1]*pr[n+((i-j-1)&gt;&gt;1)]);    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Construction"]},{"title":"CF1033G Chip Game","url":"/post/CF1033G/","content":"题意\r\nAlice 和 Bob 在玩一个游戏，游戏中有  堆筹码，其中第  堆中有  个筹码。\r\n然后有两个常数 ，每回合 Alice\r\n可以选择一堆取出  个筹码，Bob\r\n可以选择一堆取出 \r\n个筹码，直到某回合不能继续操作的一方判负。\r\n假设双方每次都会选择最优策略，对于一对 ，则有四类可能的局面：\r\n\r\nAlice 必胜。\r\nBob 必胜。\r\n先手必胜。\r\n后手必胜。\r\n\r\n在所有 \r\n的二元组中，每类局面各出现多少次？\r\n\r\n约定\r\n以下假设 ，此时不存在 Bob\r\n必胜。\r\n显然 Alice 必胜的数量跟 Bob 必胜的数量是相等的。\r\n思路\r\n我们先考虑如果 \r\n固定了怎么求出输赢情况。\r\n首先就是对于一堆 ，它与 \r\n是等价的，我们考虑现在有一个所有 \r\n的“最小局面”，那么接下来要证明“最小局面”任意一堆加上一个 ，输赢情况不变。\r\n分两种情况讨论：\r\n\r\n某一方在新加的 \r\n中连取了两次：\r\n那么剩下一个局面，无论哪方胜，他最多有一步的优势，那么我们把这两步中的一步挪到最后，就变成了连取这一方胜，所以这种情况不存在（可能有点奇怪，你可以看作为在后面的局面中另一方有一个不能取这堆的禁手，所以带来了这样的劣势）。\r\n无人取这新加的 ：\r\n显然当其他堆取完了，必然要取这堆，所以这种情况不存在。\r\n\r\n那么我们就证明了，这一堆必然要被取，并且只要被取，就一定是 Alice\r\n取一次，Bob 取一次。\r\n那么我们将操作重排，一定可以得到双方先取走了新加的这 ，并且先后手不变的一种前两步。\r\n而我们的证明并没有涉及原先是“最小局面”，所以重复这个过程，即可得到非“最小局面”的任意情况。\r\n\r\n于是我们所有的  都对  取了模，然后考虑下一步。\r\n接下来会有以下四种点：\r\n\r\n亡点：，这种完全不用管。\r\nA 点：，必然由\r\nAlice 取走。\r\n半 A 点：，这个点如果 Alice 取了变成 A 点，如果 Bob\r\n取了变成亡点。\r\n中立点：，任意一方取了变成亡点。\r\n\r\n然后讨论一下获胜情况：\r\n\r\n仅存在中立点，且为奇数，先手必胜；\r\n仅存在中立点，且为偶数，后手必胜；\r\n存在 A 点，Alice 必胜；\r\n如果存在一个半 A 点，中立点为奇数，那么 Alice 必胜；\r\n如果存在一个半 A 点，中立点为偶数，那么先手必胜；\r\n如果存在多于一个半 A 点，Alice 必胜。\r\n\r\n对于  显然，然后  考虑双方第一步都一定是取半 A\r\n点并转化为 。\r\n\r\n那么我们可以判定输赢情况，考虑如何计数。\r\n由于我们需要对所有 ，所以我们先枚举 。\r\n接下来，我们对所有点排序，然后枚举  的一个范围，这样  也确定下来，显然如果存在  那么 Alice\r\n必胜，所以我们快进到 。\r\n那么这样就没有 A 点了，我们需要考虑是否存在半 A 点，即 ，然后再把次大值也限制一下，这样把两个半 A\r\n点的情况再划到 Alice 必胜中。\r\n然后对于仅有一个半 A 点以及没有半 A\r\n点的情况，中立点的个数是十分好算的（因为  的可能的范围不跨过任何一个 ）。\r\n这样完成一次计数的时间是 \r\n的。\r\n因为排序，总的时间复杂度 。\r\nCODE\r\n但是这是我在搬题的模拟赛上 4h\r\n写的代码，现在我不知道我当时在写什么。\r\n\r\n我找到当时写的题解了，让我搬过来：\r\n然后枚举  的值（设其为 ），这样模意义下的  就是确定的。\r\n然后考虑维护一个序列表示当 \r\n为某个值时，决策的情况。\r\n那么对于每个  就会有：\r\n\r\n令 \r\n含有左点。\r\n这种情况记录最大值即可。\r\n令 \r\n增加一个半左点。\r\n这种情况记录最大值和次大值，次大值之后的视为有左点。\r\n反转 \r\n的中立点情况。\r\n这种排序以后跟前面两种标记分讨亿下。\r\n\r\n\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=110,M=200010,FSIZE=1&lt;&lt;13;using ll=long long;int n,c,b[N];ll a[N],leftwin,firstwin,lastwin;char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}void check(int x){    bool half=0;    for(int i=1;i&lt;=n;++i)        half^=a[i]%(x+x)&gt;=x;    ++(half?firstwin:lastwin);}void get(int x){    int l=max(1,x-c),r=min(c,(x&gt;&gt;1)-1+(x&amp;1)),maxa=0,maxs0=0,maxs1=0;    for(int i=1;i&lt;=n;++i){        b[i]=a[i]%x;        maxa=max(maxa,min(x-b[i]-1,b[i]));        if(b[i]&gt;&gt;1&gt;maxs0){            maxs1=maxs0;            maxs0=b[i]&gt;&gt;1;        }else if(b[i]&gt;&gt;1&gt;maxs1) maxs1=b[i]&gt;&gt;1;        b[i]=min(b[i],r);    }    maxa=max(maxa,max(maxs1,l-1));    maxs0=max(maxa,maxs0);    leftwin+=maxa-l+1;    sort(b+1,b+n+1);    if(b[n]&lt;l){        lastwin+=(r-l+1)&lt;&lt;1;        return;    }    int i=1;    for(;b[i]&lt;l&amp;&amp;i&lt;=n;++i);    for(;b[i]&lt;=maxa&amp;&amp;i&lt;=n;++i);    for(;b[i]&lt;=maxs0&amp;&amp;i&lt;=n;++i)        if((n-i+1)&amp;1) firstwin+=(b[i]-max(b[i-1],maxa))&lt;&lt;1;        else leftwin+=b[i]-max(b[i-1],maxa);    if(i&lt;=n){        if((n-i+1)&amp;1) firstwin+=(maxs0-max(b[i-1],maxa))&lt;&lt;1;        else leftwin+=maxs0-max(b[i-1],maxa);        ((n-i+1)&amp;1?firstwin:lastwin)+=(b[i]-maxs0)&lt;&lt;1;    }    for(++i;i&lt;=n;++i)        ((n-i+1)&amp;1?firstwin:lastwin)+=(b[i]-b[i-1])&lt;&lt;1;    lastwin+=(r-b[n])&lt;&lt;1;}int main(){    fread(BuF,1,FSIZE,stdin);    read(n);read(c);    for(int i=1;i&lt;=n;++i) read(a[i]);    for(int i=1;i&lt;=c;++i) check(i);    for(int i=3;i&lt;c+c;++i) get(i);    printf(\"%lld %lld %lld %lld\\n\",leftwin,leftwin,firstwin,lastwin);    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Math","Game"]},{"title":"AT Birthday0410 X - 论如何在 3k 以内解决战斗","url":"/post/AT_birthday0410_X/","content":"TL;DR\r\n本题可以以  在\r\nLinux 上通过测试。\r\n本题可以以  在\r\nWindows 上通过测试。\r\n前言\r\nupd 2022/7/15: 优化到 7k 以下，原先 9k。\r\nupd 2022/8/1:\r\n修正了一些错误，之前的不计换行符应为换行符记为一个字符，记换行符应为换行符记两个字符；增加了新内容。\r\n\r\n2022/8/1: 最终停在了 4k 的门槛上啊，累了。\r\n\r\nupd 2022/8/2:\r\n发出来之后发现了一些不能容忍的错误。以及隔了一天之后我又不累了。\r\n\r\n2022/8/2: 进入了 4k 大关。\r\n\r\nupd 2022/9/24: 进入 3.6k 大关。\r\nupd 2022/10/27: 修复代码错误。\r\nupd 2022/11/11: 答案是优化之后的代码只能在 Windows\r\n系统上跑。\r\n\r\n2022/11/11: 答案是 Western Windows-1252 编码，我的评价是：笨比 Linux\r\n的游戏理解就到这了好吧。\r\n\r\nupd 2022/11/12: ，永远永远的结束了。\r\n\r\n我寻思这题也不难啊，我才交了四发搞定一些弱智错误就有 480\r\n了。\r\n\r\n要 A 掉不就交了 17\r\n发，花了两个晚上一个下午大概两位数小时么。\r\n论如何在 23k\r\n以内迅速地解决战斗\r\n首先（一开始）我没有使用压缩技术把图像压缩进去。\r\n当时写着写着，开始调了，突然发现自己好像可以（在洛谷上）整个最短解。\r\n降噪与分离\r\n首先因为这题是个大模拟，考虑封装一个 image\r\n类便于操作图像：\r\nstruct image{    int rx,ry;  // 长宽信息    vector&lt;vector&lt;bool&gt;&gt; raw,null,vis;    // raw 表示图像信息，null 表示空的图（用于给 vis 赋值），vis 是工具人（    image(const char *s){  // 从字符串构造，以换行符作为分隔符        int i=0;        raw.resize(1);        null.resize(1);        for(;*s!=0;++s)            if(*s=='\\n'){                if(raw[i].size()&lt;raw[0].size()) break;                null[i].resize(raw[i].size());                raw.resize(++i+1);                null.resize(i+1);            }else                raw[i].push_back(*s=='#');        ry=raw[0].size();        if((int)raw.back().size()&lt;ry){            raw.pop_back();            null.pop_back();        }        rx=raw.size();    }    image(int x,int y){  // 给定长宽，构造一个空图像        raw.resize(rx=x+1);        ry=y+1;        for(int i=0;i&lt;=x;++i) raw[i].resize(y+1);        null=raw;    }   }\r\n众所周知我们在处理二维图的时候经常要要遍历整张图，或者对一个点去寻找与它联通的点，所以我们可以考虑对这两种东西做一个封装：\r\nstruct image{    // ......    template&lt;class A,class B&gt;    void expand(int x,int y,bool now,const A &amp;check,const B &amp;next){        // 拓展一个点周围的点        for(int i=0;i&lt;8;++i){            int nx=x+fx[i][0],ny=y+fx[i][1];            if(~nx&amp;&amp;~ny&amp;&amp;nx&lt;rx&amp;&amp;ny&lt;ry&amp;&amp;check(nx,ny)&amp;&amp;raw[nx][ny]==now)                next(nx,ny);        }    }    template&lt;class T&gt;    void foreach(const T &amp;func){        // 遍历整张图        for(int i=0;i&lt;rx;++i)            for(int j=0;j&lt;ry;++j)                func(i,j);  // 对每个点执行函数    }}\r\n\r\n然鹅后来发现 expand 用的太少了，我给它优化掉了。\r\n\r\n具体用法，比如我们要降噪，使用众数滤波器，要统计周围的合法的点数以及黑点的数量，就可以这么写：\r\nstruct image{    // ......    image &amp;reno(){        vis=null;  // null 是在初始化时创建好的一个空二维 vector，这句话等同于清空        foreach([&amp;](int i,int j){            int all=1,bk=raw[i][j];            expand(i,j,1,                   [&amp;](int x,int y){                       ++all;                       // 这是 check，这就是为什么 check 的判断放在了判断颜色连通性之前                       return(1);                   },                   [&amp;](int x,int y){                       ++bk;                       // 这是 next，由于判断了颜色为 1，直接加即可。                   });            raw[i][j]=bk&lt;&lt;1&gt;all;        });        return(*this);    }}\r\n\r\n众数滤波，即对每个点计算（包含自身的）周围的点的情况，选取最多的颜色进行着色。\r\n不过这里其实可以不统计四周合法点的数量，接触边缘的点我们可以直接当作噪音。\r\n\r\n再比如，我们调试要输出整张图像，就可以这么写：\r\nstruct image{    // ......    void print(){        foreach([&amp;](int x,int y){            putchar(raw[x][y]?'#':' ');            if(y==ry-1) puts(\"\");});    }}\r\n\r\n这个 print 太好使了，没有它根本没法调试。\r\n指写出了\r\ncharset[i].rotate(j).cut(-.1,-.1).reno().print()\r\n的魔怔人。\r\n\r\n然后接下来，由于我们对图像做操作，以及分离的时候需要框出图像的四边，所以我们再封装一个类：\r\nstruct sqr{    int x0,x1,y0,y1;    void operator+=(const sqr &amp;b){        x0=min(x0,b.x0);x1=max(x1,b.x1);        y0=min(y0,b.y0);y1=max(y1,b.y1);    }    void operator+=(pair&lt;int,int&gt; b){        x0=min(x0,b.first);x1=max(x1,b.first);        y0=min(y0,b.second);y1=max(y1,b.second);    }};\r\n分离大概长这样：\r\nstruct image{    // ......    sqr find(int x,int y){  // 遍历整个连通块，返回图像四周的坐标        sqr re={x,x,y,y};        vis[x][y]=1;        expand(x,y,raw[x][y],               [&amp;](int x,int y){return(!vis[x][y]);},               [&amp;](int x,int y){re+=find(x,y);});        return(re);    }    image get(int x,int y){  // 将连通块所占据的矩形复制成新的图像        sqr out=find(x,y);        image re(out.x1-out.x0,out.y1-out.y0);        for(int i=out.x0;i&lt;=out.x1;++i)            for(int j=out.y0;j&lt;=out.y1;++j)                re[i-out.x0][j-out.y0]=raw[i][j];        return(re);    }    vector&lt;image&gt; split(){        vector&lt;image&gt; re;        vis=null;        for(int i=0;i&lt;ry;++i)            for(int j=0;j&lt;rx;++j)                if(raw[j][i]&amp;&amp;!vis[j][i]){                    re.emplace_back(get(j,i));                    if(re.back().rx*re.back().ry&lt;80)                        re.pop_back();                    // 判断块大小，太小的直接放弃，防止降噪不充分（真的会发生的）                }        return(re);    }}\r\n然后我们就得到一个由 image 组成的\r\nvector，下一步可以开始匹配了。\r\n不过在此之前……\r\n变换与预处理\r\n首先我们先把基础字体塞进一个 vector&lt;image&gt;\r\n里面，使用 C++11 的原始字符串字面量，大概像这样：\r\nvector&lt;image&gt; charset({R\"(.#.#.##.##.#.#.)\",R\"(##..#..#..#.###)\",R\"(###..#####..###)\",R\"(以下省略)\"});\r\n众所周知只有基础字体的图像（以下称“本源图像”），我们是不可能 A\r\n掉这道题的。\r\n由于题目给出的图像已经变换的很厉害了，所以试图对这些图像做逆变换可能不是个好主意。所以我们要对本源图像做亿些变换，使得它们更加像题目中给定的图像。\r\n然后看到题目中给出了变换顺序：\r\n\r\n整体缩小。\r\n对  方向与  方向分别缩小（改变比例）。\r\n旋转  度。\r\n剪切变换。其实最开始我没看到这个变换所以只拿了 480\r\n分，看到之后就有 490 了。\r\n\r\n所以我们的图像也要按顺序变换，先进行旋转。\r\n\r\n这个问题是这样的，因为缩放的参数预先猜测效果并不好，但是如果其他变换都做完了，缩放的参数其实可以通过图像信息得出，所以我们不妨到了要匹配的时候再进行缩放。\r\n\r\n旋转按照公式写即可：\r\nstruct image{    // ......    image rotate(db ang){        vector&lt;pair&lt;int,int&gt;&gt; point;        sqr out={INF,-INF,INF,-INF};        // 创建一个黑点集合，以及记录集合的四边        ang=ang/180*pi;        db csa=cos(ang),sia=sin(ang),cex=rx/2.,cey=ry/2.;        foreach([&amp;](int x,int y){            if(!raw[x][y]) return;            db nx=(x-cex)*csa+(y-cey)*sia,ny=-(x-cex)*sia+(y-cey)*csa;            // 按照公式变换            point.emplace_back(nx+cex,ny+cey);            out+=make_pair(nx+cex,ny+cey);});        image re(out.x1-out.x0,out.y1-out.y0);        for(auto i:point)            re[i.first-out.x0][i.second-out.y0]=1;        // 将黑点集合放入图像        return(re);    }}\r\n然后是剪切变换：\r\nstruct image{    // ......    image cut(db cx,db cy){        vector&lt;pair&lt;int,int&gt;&gt; point;        sqr out={INF,-INF,INF,-INF};        // 创建一个黑点集合，以及记录集合的四边        foreach([&amp;](int x,int y){            if(!raw[x][y]) return;            db nx=x+y*cy,ny=y+x*cx;  // 按照公式变换            point.emplace_back(nx,ny);            out+=make_pair(nx,ny);});        image re(out.x1-out.x0,out.y1-out.y0);        for(auto i:point)            re[i.first-out.x0][i.second-out.y0]=1;        // 将黑点集合放入图像        return(re);    }}\r\n封装的收益这个时候就体现出来了。\r\n最后是缩小操作（强调缩小是因为放大需要额外增加黑点，比较难处理，我写的这个比较简单，只能缩小）：\r\nstruct image{    // .....    image fit(int rxt,int ryt){  // 这里传入的是目标的图像大小        image re(rxt,ryt);        db delx=(db)rxt/rx,dely=(db)ryt/ry;  // 计算缩小比例        foreach([&amp;](int x,int y){            if(raw[x][y]) re[x=x*delx][y=y*dely]=1;});        return(re);    }}\r\n然后在预处理中搞出若干张图像来，方便处理。我没有使用随机，而是直接按照一定分度值枚举参数。\r\nvoid init(){    for(int i=0;i&lt;16;++i)  // 枚举字符        for(db j=-15;j&lt;16;j+=3){  // 枚举旋转角            auto tmp=charset[i].rotate(j);            trans[i].emplace_back(tmp.cut(-.1,-.1).reno());            trans[i].emplace_back(tmp.cut(-.1,.1).reno());            trans[i].emplace_back(tmp.cut(.1,-.1).reno());            trans[i].emplace_back(tmp.cut(.1,.1).reno());            // 我们只对四角的最极端的四种剪切做预处理，事实证明这是足够的            trans[i].emplace_back(tmp.reno());        }}\r\n这里使用降噪是因为变换容易搞出中心空点。\r\n匹配与计算\r\n也就是主函数！\r\n我们使用暴力匹配法，对于每一个位置进行匹配，最后通过匹配的数量除以总的数量得到匹配率。\r\nstruct image{    // ......    db match(image &amp;x){        if(min(abs((db)ry/rx-(db)x.ry/x.rx),abs((db)rx/ry-(db)x.rx/x.ry))&gt;0.25)             return(0);        // 对于长宽比相差过大的直接放弃，否则在进行剧烈缩小的时候会丢失大量的信息导致误判        int re=0,mix=min(rx,x.rx)-1,miy=min(ry,x.ry)-1;        // 这里我们将两张图像都进行缩小，按照两个维度缩小到最小的大小，因为并不能放大        // fit 没写好，所以我要减一        auto a=this-&gt;fit(mix,miy),b=x.fit(mix,miy);        a.foreach([&amp;](int x,int y){re+=a[x][y]==b[x][y];});        return((db)re/(a.rx*a.ry));  // 返回使用比例，因为每次匹配的大小是不定的    }}\r\n那么经过了大量的封装，主函数只需要调用即可：\r\nint main(){    init();    fread(BuF,1,FSIZE,stdin);    read(t);read(n);read(m);    for(;*InF&lt;33;++InF);    image in(InF);    for(auto &amp;i:in.reno().split()){        db bestmatch=0,tmp;        int bestnum=0;        for(int j=0;j&lt;16;++j){            tmp=i.match(charset[j]);            if(tmp&gt;0&amp;&amp;tmp&lt;.5) continue;            // 先对本源图做一次匹配，如果匹配率太低直接放弃            for(auto &amp;k:trans[j])                if((tmp=i.match(k))&gt;bestmatch){                    bestmatch=tmp;                    bestnum=j;                }        }        ans+=charname[bestnum];    }    printf(\"%d\\n\",calc(ans));}\r\n计算我是直接 copy 的，大家可以去看其他的题解（雾）。\r\n最后一步\r\nFinal Step!\r\n把所有的空格缩进换成 Tab （雾）。\r\n后记\r\n这道题我实际写起来比想的容易很多（？\r\n一开始甚至没有看到剪切操作就拿到了 480pts。\r\n这也证明了考场上打这个做法是非常不错的，因为好写又好拿分（？\r\n感谢 @xiyihan\r\n提供的字符表以及最后一步计算的代码（指我直接进行一个厚颜无耻的\r\ncopy）。\r\n完整代码可以在 AtCoder 的提交记录中查看。\r\n最后，Clang 吊打 GCC！\r\n\r\n论如何在 9k\r\n以内优雅地解决战斗\r\n字符表压缩\r\n首先我们观察字符表，发现这东西巨大，肯定要压缩。\r\n我选择了游码，主要是因为它易于解码，而且这题的字符集为二，非常适合游码发挥（更好的方法解码更复杂，效果其实没有理论那么好）。\r\n实测大约是 \r\n的压缩率，效果还是很不错的。\r\n具体的过程，我们可以将输入看作为一维字符串进行，解码时再额外传一个宽度即可还原成二维矩阵。\r\nstruct image{    // ......    image(initializer_list&lt;int&gt; v){        // initializer_list 的第一个值是宽度        int i=0;bool p=0;auto k=v.begin();        raw.resize(1);        null.resize(1);        for(ry=*k;++k!=v.end();p^=1)            for(int j=0;j&lt;*k;++j){                raw[i].eb(p);                if(raw[i].size()==ry&amp;&amp;k+1!=v.end()){                    // 对于最后一个数据不再新开一行                    raw.resize(++i+1);                    null.resize(i+1);                }            }        rx=raw.size();    }}\r\n然后我们的 16 个字符就是这样的画风：\r\nvector&lt;image&gt; charset({{30,11,8,20,12,16,16,13,18,11,20,9,22,7,24,6,10,4,10,5,9,8,9,4,8,10,8,3,9,10,9,2,8,12,8,2,8,12,8,2,8,12,8,1,8,14,16,14,16,14,16,14,16,14,16,14,16,14,16,14,16,14,16,14,16,14,8,1,8,12,8,2,8,12,8,2,8,12,8,2,9,10,9,3,8,10,8,4,9,8,9,5,10,4,10,6,24,7,22,9,20,11,18,13,16,16,12,20,8},{27,13,4,21,7,17,10,14,13,11,16,10,17,10,17,10,17,10,17,11,6,2,8,11,3,5,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,10,134,1,26},{28,9,9,16,14,11,19,8,21,6,23,5,23,5,24,4,9,6,9,4,7,9,9,3,7,10,8,3,7,10,8,3,7,10,8,3,7,10,8,4,6,10,8,19,9,19,8,19,9,18,10,17,10,17,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,5,5,6,11,5,7,4,11,6,7,3,11,7,7,2,11,8,7,1,11,9,147,1,27},{28,9,10,14,16,10,20,7,22,6,23,5,24,4,24,4,8,7,10,3,7,9,9,3,7,10,8,3,7,10,8,4,6,10,8,20,8,20,8,19,8,19,9,12,15,12,15,13,14,14,15,13,16,13,16,19,10,20,8,20,9,20,8,20,8,20,8,20,8,19,9,2,3,13,10,1,8,8,10,2,26,2,25,2,26,3,24,4,22,9,17,14,11},{30,17,5,24,7,22,8,21,9,20,10,19,11,19,11,18,12,17,13,16,14,15,15,14,16,14,8,1,7,13,8,2,7,12,8,3,7,11,8,4,7,10,9,4,7,10,8,5,7,9,8,6,7,8,8,7,7,7,180,15,8,22,8,22,8,22,8,22,8,22,8,16,20,9,21,9,21,9,21,9,21,10,20},{28,3,22,6,23,5,23,5,23,5,23,5,22,6,7,21,7,21,7,21,7,21,7,21,7,20,8,2,8,10,20,8,22,6,23,5,24,4,24,4,25,3,8,7,10,6,2,11,9,20,9,20,8,20,8,20,8,20,8,20,8,20,8,3,1,15,9,2,4,12,9,2,8,7,11,2,26,2,25,2,25,4,23,6,21,9,17,15,10},{29,20,6,18,11,15,15,12,17,10,19,9,20,8,20,8,16,12,12,16,11,18,9,19,9,20,8,20,8,21,8,21,7,4,8,10,7,2,13,6,25,4,26,3,27,2,27,2,12,6,10,1,10,9,9,1,9,11,17,13,16,13,16,13,8,1,7,13,8,1,7,13,8,1,8,11,9,1,9,9,9,3,10,5,11,4,25,4,24,6,22,8,20,10,18,13,14,18,8},{28,0,27,1,139,1,7,11,9,1,7,11,9,1,7,10,9,2,7,10,9,2,7,10,8,3,7,9,9,3,7,9,8,4,7,8,9,5,5,9,9,19,8,19,9,19,8,19,9,19,8,19,9,19,9,19,8,19,9,19,8,19,9,19,8,20,8,19,8,20,8,19,9,19,8,20,8,19,8,20,8,20,7,21,7,23,5},{28,10,9,17,13,13,17,10,19,8,21,6,23,5,23,5,9,5,9,4,9,7,9,3,8,9,8,3,8,9,8,3,8,9,8,3,8,9,8,3,8,9,8,4,8,7,8,5,9,5,9,6,21,8,19,10,17,11,17,9,21,6,23,4,9,6,10,2,8,10,8,2,8,10,17,12,16,12,16,12,16,12,17,10,18,10,9,1,10,6,10,2,26,3,24,4,24,5,22,7,20,10,16,15,10},{28,9,9,17,13,13,17,10,19,8,21,6,23,4,24,4,10,6,9,3,9,8,9,1,9,10,8,1,8,12,7,1,8,12,7,1,8,12,16,12,16,12,17,10,9,1,8,9,10,1,10,6,11,2,26,2,26,3,25,4,24,6,12,2,8,8,8,4,7,21,7,20,8,20,8,19,8,19,9,17,10,16,12,12,15,8,19,8,19,9,18,10,16,12,14,14,12,17,6},{21,15,4,16,6,13,8,12,10,10,11,9,12,8,12,8,11,9,11,9,11,10,10,10,10,11,9,11,9,12,8,12,9,12,8,12,9,12,8,13,8,13,8,12,9,12,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,14,8,13,8,13,8,13,9,13,8,13,9,12,9,13,9,12,10,12,9,13,9,12,10,12,11,11,11,11,11,11,12,10,11,11,10,12,9,13,7,16,4,19,1},{21,2,4,16,6,14,9,12,10,11,11,10,12,10,12,11,11,11,11,11,10,12,10,12,10,12,9,13,9,13,8,13,9,13,8,13,9,13,8,13,8,13,8,13,9,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,12,8,13,8,13,8,12,9,12,8,12,9,12,9,11,9,11,10,10,10,11,9,10,11,9,11,9,11,9,11,8,12,9,11,10,10,11,9,13,7,15,4,18,1},{27,11,5,21,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,10,189,10,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,21,5},{28,1,26,1,140,1,32},{26,11,4,21,6,20,7,18,8,18,8,19,7,19,6,11,5,4,6,5,4,2,6,3,6,3,16,2,5,1,24,1,62,1,24,7,14,15,8,17,11,14,13,11,8,1,7,9,8,2,8,8,8,2,9,6,8,4,8,6,8,4,8,7,7,5,7,8,5,6,6,10,3,9,2},{28,22,4,24,6,21,7,21,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,21,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,22,6,23,5}});\r\n\r\n这里缩了一点点，删掉了最后一个数字，即忽略掉了最后的若干个\r\n0，因为初始就会填充为 0.\r\n大概？我也不知道为什么没有 push_back\r\n能行，反正过了。\r\n\r\n2022/10/27 更新\r\n这是一个 STL 特性，因为 vector&lt;&gt; 对\r\nbool 类型特化，使用 64 位整数（取决于机子，如果是 32\r\n位机子就 32 位整数，跟 bitset&lt;&gt;\r\n一个道理），来储存信息。\r\n这就会导致其实我们的 vector 长度如果小于 64\r\n的话实际上对于内存而言没什么意义，因为它至少要开一个整数。\r\n而显然的，我们字符集中的字符宽度小于 64（哪怕 32\r\n也恰好没到），所以每一行都只会使用一个整数储存。\r\n这就意味着，虽然我们的最后一行没有\r\npush_back，但是内存是存在的，所以我们在访问这些位置时不会越界，而只是会得到随机值（访问未初始化内存）。\r\n但这无关紧要，因为它一定会被降噪干掉。\r\n所以如果你使用 int 存，但是提前 reserve\r\n一下的话，大概也是这个效果吧。\r\n重构与优化\r\n\r\n我们把 expand\r\n优化了（因为只在类的内部调用了两次，而且 API\r\n还不是很合适，所以给它内联掉）。\r\n我们把 get\r\n优化了（因为只在类的内部调用了一次，所以给它内联掉）。\r\n因为 push_back 与 emplace_back\r\n太多了，所以全部替换成 #define eb emplace_back。\r\n返回值可以用 auto。\r\n我们发现 rotate 与 cut\r\n包含大量重复代码，所以我们可以：\r\ntemplate&lt;class T&gt;image trans(T func){    vector&lt;pair&lt;int,int&gt;&gt; point;    sqr out={INF,-INF,INF,-INF};    foreach([&amp;](int x,int y){        if(!raw[x][y]) return;        auto p=func(x,y);        // 对坐标进行变换，返回一个 pair&lt;double,double&gt; 表示新坐标        point.eb(p);        out+=p;});    image re(out.x1-out.x0,out.y1-out.y0);    for(auto i:point)        re[i.first-out.x0][i.second-out.y0]=1;    return(re);}\r\n然后 rotate 变成这样：\r\nauto rotate(db ang){    ang=ang/180*pi;    db csa=cos(ang),sia=sin(ang),cex=rx/2.,cey=ry/2.;    return(trans([&amp;](int x,int y){        return(make_pair((x-cex)*csa+(y-cey)*sia+cex,-(x-cex)*sia+(y-cey)*csa+cey));}));}\r\ncut 这么写：\r\nauto cut(db cx,db cy){    return(trans([&amp;](int x,int y){return(make_pair(x+y*cy,y+x*cx));}));}\r\n优化最后的计算代码。\r\n其他非常多的优化，有兴趣的话还是翻到下面见源码吧。\r\n\r\n最后一步\r\n把所有的空格缩进换成 Tab （大雾）。\r\n后记\r\n你怎么这么多后记！\r\n感谢 @xiyihan\r\n的题解提供的思路 以及让我看到了这道题是可以写的。\r\n在没有过多的牺牲代码的可读性的前提下（没有过于奇怪的变量名以及过度离谱的压行），最终得到的代码约有\r\n 的有效代码以及\r\n 的数据。\r\n用 Clang 提交最慢的数据点耗时 ，总的效率还是不错的。\r\n完整代码见提交记录。\r\n再复读一遍愚蠢的 GCC：\r\n\r\nPython\r\n占据最短提交第一的历史，终于结束了。虽然我估摸着很快就会有人给我干掉。\r\n论如何在 8k 以内解决战斗\r\n额，我们直接进入正题吧。\r\n但是我们并不满足于 \r\n的压缩率。\r\n\r\n以下“压缩组”指游码得到的一个数，即一个表示一块相同颜色的大小的数。\r\n\r\n我们观察压缩表，发现里面有大量的一位数与二位数，实际上，使用优秀的文本编辑器我们可以快速看出里面最大的二位数是一个\r\n，而第二大的是 。\r\n而三位数并没有几个，最大的是 。\r\n这启发我们可以将小数字压缩起来，我们按照 \r\n为一个单位放入数字（恰好可以放入 ），如果数字大于 \r\n就强制完成当前数字，注意如果出来的数字小于 \r\n则需要还原回去（似乎实战并没有这种情况）。\r\n需要注意的是 unsigned long long 有 ，对  取模余 ，这样最后一个数字可能差 \r\n写不进去，但也有可能能写进去（能写进去即小于 ），这需要判断一下。\r\n解码仍比较简单，我们对于小于 \r\n的数直接按照一个压缩组处理，对于大于等于（虽然也没有等于）的数按照 \r\n为一节从低到高拆开，然后依次作为压缩组处理即可。为了照顾解码器，我们选择将靠前的数字放到小端，这顺便可以解决数字\r\n 游码压缩后第一个数为  的问题。\r\n将较大的数字按照 \r\n进制输出，最终压缩率大约为 。\r\n压缩器代码：\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;using uni=unsigned long long;const int FSIZE=1&lt;&lt;20;const uni INF=0xffffffffffffff;vector&lt;uni&gt; ans;char BuF[FSIZE],*InF=BuF;void push(uni &amp;x){    if(x&gt;189) ans.push_back(x);  // 如果大于等于 190 则直接放入    else if(x)  // 否则进行解构，还原成原始状态        for(;x;x&gt;&gt;=4)            ans.push_back(x&amp;15);    x=0;}int main(){    for(;~scanf(\"%s\",InF);*InF++='\\n') for(;*InF;++InF);    bool p=0;    uni rest=0,t=0,now=0;    for(InF=BuF;*InF;++InF){        for(;*InF&lt;33&amp;&amp;*InF;++InF);        if(*InF!='.'&amp;&amp;*InF!='#') continue;        if((*InF=='#')==p) ++now;        else{            if(now&gt;32||t&gt;60||(t==60&amp;&amp;now&gt;15)){  // 因为过大或溢出而不能放入压缩数中                push(rest);                t=0;            }            if(now&lt;32){  // 能放入压缩数中                rest+=now&lt;&lt;t;                t+=5;            }else{                push(rest);                t=0;                ans.push_back(now);            }            now=1;            p^=1;        }    }    if(now&gt;32||t&gt;60||(t==60&amp;&amp;now&gt;15)){        push(rest);        t=0;    }    if(now&lt;32){        push(rest+=now&lt;&lt;t);    }else{        push(rest);        ans.push_back(now);    }    for(auto i:ans){        if(i&lt;10000000000){            printf(\"%llu,\",i);        }else{            printf(\"0x%llx,\",i);        }    }}\r\n解压器（即 image 类的构造函数）如下：\r\nstruct image{    // ......    image(initializer_list&lt;uni&gt; v){        int i=0;bool p=0;auto k=v.begin();        raw.resize(1);        auto get=[&amp;](int k){            for(int j=0;j&lt;k;++j){                raw[i].eb(p);                if(raw[i].size()==ry) raw.resize(++i+1);            }            p^=1;};        for(ry=*k;++k!=v.end();)            if(*k&lt;190) get(*k);            else for(uni x=*k;x;x&gt;&gt;=5) get(x&amp;31);        raw.pop_back();        null.resize(rx=raw.size());        for(int i=0;i&lt;rx;++i) null[i].resize(ry);    }}\r\n最终得到的压缩表如下：\r\nvector&lt;image&gt; charset({{30,0x7b268b936106510b,0x852089424aa228d8,0x243102431024a923,0x741d0741c80a188,0x741d0741d0741d0,0x812188121880a1d0,0x84910a40d2a4890c,0x5d1363e0ca228a9,9274147250,11},{27,0xa8aa0b6b9513d48d,0x828d681197154551,0x44d1344d1344d13,0x44d1344d1344d13,0x44d1344d1344d13,0x291344d13,134,833},{28,0xb96e6aa26b74129,0x38d293912649305,0x38d0a38d0a38d0a,0x4cd134cd0a3110a,0x5c1705c17154552,0x598a55c1705c170,0x588e758ce6590e5,9798888,147,865},{28,0x4c16e6b1e8a83949,0x851c6949c6a3a098,0x45114428c4428e3,0xd7b9cd7b1ec4cd13,0x8a2289a228a9c1b0,0x84054d1893345114,0x4d8981e8591684a,339409},{30,0x5cd544d5163e0b1,0xe839ef741b164973,0x859c6861c4869c28,0x6424e5428e44a8e4,242458887,180,0x45916459164590f,0x1a2aa9aa6a9aa690},{28,0x6b16e5b96e5b9ac3,0x8a1ea7a9ea7a9ea7,0x4c1305b9ac8a2902,0x8a2689588ca3a079,0xf08d144511445114,0x1684b3a04961049,0x529f14d4d726459},{29,0x8a266a8b1ef5c8d4,0x8a266992e0c64114,0x6688ea410f545514,0xa0a8cc16c5b1e899,0x14360d8362b48529,0x90a5680a1a70a1a7,0x8b1b04c916550d29,0x5224e6c954},{28,1888,139,0x24a8e14ace14ace1,0x71a5271a14712547,0x44d292952839109,0x4cd3344d3344d33,0x451134cd134cd13,0x44d1444d3345113,0xe2dcf53d114},{28,0x5b9aa89aa2d6c52a,0x84a0693a4892a4b7,0x3425034250342503,0x324a92a0e822128,0x925cd54c57154d15,0xc8322a4090a40946,0xa328295495164190,0xf82a87b1704c0f42,298},{28,0x4b9aa89aa2d6c529,0x8524294246932898,0xc831013b1013b101,0xb3282a4a02954590,0x840986c1323d0b42,0x99a268a2287a9c88,0xa926689a1ec64151,0x91a2c73990},{21,0x86256a5310d3408f,0x95a94a52d2b4ad0c,0xd4312c4312c4312b,0x86a1a86a189621a8,0xe4350d4350d4350d,0x9625a86a5a86a1a8,0xb5b14c4b52c5312d,0x76a58a5ad4c5ad6b,3198096},{21,0xa6296b5312e34082,0x96298a6296b5ad6c,0xd4352d4352d4352d,0x86a1a86a1a96a1a8,0xc4350d4350d4350d,0x962588625886a1a8,0x95a56a4ad4a52d2b,0x76a56a52d2c42d2b,17877135},{27,0x3d0f43d0f43d4ab,0xa3d0f43d0f4,189,0x3d0f43d0f43d0ea,0x2cb53d0f43d0f4},{28,1857,140,865},{26,0x3cd12448f43548b,0x330cc2214c42acd3,58758224,62,0x142dae5c50f71f01,0x8220c91210812127,0xa318a8394e741106,198947},{28,0x3d1143d4f536096,0x3d1143d1143d114,0x450f4450f445114,0x450f4450f4450f4,0x3d1143d4f4450f4,0x3d1143d1143d114,0x451143d1143d114,0x450f4450f4450f4,0x54b7358f4}});\r\n最后的代码长度 ，压缩表 。\r\n完整代码仍然是见 AtCoder 上的提交记录，不过这份代码的压缩表有一点点小问题，比上面给的多了\r\n。\r\nAnything More Exciting?\r\n到这一步我其实不大会了，但是还是有一些不那么聪明的办法继续压缩。\r\n我们发现我们的数字都是 \r\n进制，而且还有很多凑数的 0x 占位符。而众所周知，ASCII 有\r\n\r\n个可见字符和一个可以显示为一个奇怪的东西的\r\n0x7f（也就是说我们实际上有  个可用字符）。我们可以把数字转换成\r\n\r\n进制（去掉一个分隔符），然后把空格当作分隔符整个放入字符串中，这样就可以做到\r\n 的压缩率。\r\n表长度 ，如下：\r\nvector&lt;image&gt; charset({{30,\"/(Z&gt;k5rpG- 05|Tes`Cbl %.)|F7&gt;Tu5 oo3$s$lNM oo3$s/)(] /iV1d;jA&gt;K 0/t0K-(usu `2O#f.n=G S%2Op3 \"},{27,\"4;{D@&amp;Ol^x /xoT%W-H Oe%.AxXC5 Oe%.AxXC5 Oe%.AxXC5 \\\"ID8yq \\\"H )j \"},{28,\"+Mm-u+r60= 05kx9`fP'\\\\ (l?:yvmH\\\\( 4;|B@rIg:# _QwDo9;'' ,[0E@,wQP6 Sh:[IpOZP \\\"U *+ \"},{28,\")cKS}@p1aD 05kx9`@[os Ou2:MXQ0| 9`+Zk=.dpe 0lBpTs;8Fp 0)zxq3Q?Gt U]FR&gt;4oH. FZf \"},{30,\"`\\\"pAl[\\\\K# ;U@Xq(T{S6 0;5oU%v}!m ,Ke6O&gt;2pa( #}l8n \\\"v P6LVwNc`t #4ySB5i,x \"},{28,\"-8/eJXT]M8 0l32ni_ecN )c;vg@iA.j 0lR{i&lt;~bGD &lt;PhMqXvpa; 0&lt;5X1fSWr Y);f+{U:* \"},{29,\"0lRMbF!8wy 0lRL7Yx_SH ,eb&amp;_jD~Vh 3D!XEg&lt;#NV #&gt;Rj1Z7L*b 1T(FG.o^*z 0vvDh$?P\\\\d NYT%H` \"},{28,\"4t \\\"M %32,I{nYnJ -C1BZI\\\"y/ OeEu3c$?{ U/M^Xc}Q&gt; Ou0p'}`{+ Oe&amp;]KK|_d 64j90R$ \"},{28,\"+M|;cpYJ[F 00S,13#;^b &amp;|D-U=zs\\\\? C.=c-%,17 1feVt=l2qQ 7uJ6=&amp;~X}V 3_-]065&lt;&gt;e =DM\\\"WnRe=Y $. \"},{28,\")^1i*Xxot+ 06,/jya!3S 7uEU#Pb}jU 5Nx13cQ{?C 0*,{fU\\\"MZY 2Vcx.kHhAS 4A6]cbs'j4 qpQpj&lt; \"},{21,\"0A$&amp;=F3'Ba 2+U;$UvGD/ 99fCq\\\"2p_~ 0F=p1!?(*p ;)aRed1r)W 20oUjR3+f* 5jLYN_H`p2 .Va|8bD*3+ $fC1 \"},{21,\"3j7^;;Iyw 204P[FOo4 99vP~Sd5*W 0F=p1!f8a&gt; 7J+NR4p][# 20o%s!.]h_ 2+E_4w$-Zf .VaLA1?Q?5 5qqD \"},{27,R\"(JKhf2n\"v; 0&gt;qwv&gt;q \" JKhf2n\"l0 \"v42HHf&amp;g )\"},{28,\"4U \\\"N *+ \"},{26,\"J&lt;*z]Vh( &amp;pNR}bx5_b eSZ\\\\ _ #&gt;1#V6Hu.5 /tF\\\"&gt;9a{Ct 3^N.E-.1}M 7%2 \"},{28,\"JL9YFlFi\\\" JL9Y:!~TT OtaHl7%r OtaHl7%R JL9YFk8F* JL9Y:!~TT Ou27IYGzC OtaHl7%R #z3[eZ \"}});\r\n理论上还可以做的更绝一点，我们可以将 ASCII 前面 \r\n个字符（除去空字符）全部用出来（前面的字符也能显示为奇怪的东西），做到\r\n\r\n进制。但是我试了试似乎不是很行（可能是编辑器的锅，也有可能是编译器），而且只能节省\r\n 个字符，所以还是算了吧。\r\n而后面的字符会出更多的问题，它们很容易被解释为 UTF-8\r\n编码然后导致解码失败，就算本地能行（而且其实本地也很难复制这些字符，要实现可能得直接改二进制文件），复制粘贴到浏览器环境中也很有可能寄掉。\r\n2022/8/2 更新\r\n事实上，由于不同 cv\r\n限定符的同一类型作为参数允许同时出现在同一函数的重载中，所以我们可以将宽度信息当作一个压缩组编码进字符串中。\r\n发现这样十分有效，而且把新的解码器写出来，发现解码器只多了 （雾）。\r\n大概是我的码风问题。\r\n一个更有趣的是，接下来我们将 \r\n进制换成 \r\n进制，得到的结果更短。\r\n小编也很惊讶.jpg\r\n\r\n因为实操的时候，转换出的字符串并不能完美地直接使用，其中存在的\r\n\"\\ 两种字符需要转义，所以会产生一点细微的差别。\r\n原始字符串字面量可以解决这个问题，但是一个代价  有点贵。\r\n\r\n我们发现字体的一些极小的空白会影响我们的压缩（游码的特性），但是对匹配的影响不大，所以可以滤除一些空白。\r\n\r\n影响不一定都是负面的，需要一个一个地尝试来确定。\r\n\r\n然后使用 unsigned __int128！\r\n最终，我们的表长 ，压缩率为 。\r\n不过因为一些原因，以下提交记录的表长为 。\r\n2022/10/27 更新\r\n由于有了上面的结论，所以我们可以将最后一个压缩组省掉，对于最后一个压缩组为\r\n#，我们直接向本源图像人为添加一个 . 即可。\r\n表长 ，乍看起来好像有优化一样。\r\n2022/11/11 更新\r\n我试了试，可以把所有的字符都用上，只要没有空字符都能简单搞，带空字符的话就要直接改二进制文件。\r\n于是我们压缩有两个参数，进制（使用的最大字符数量）与位移（分隔符的\r\nASCII 码，从分隔符之后选取字符）。\r\n经尝试使用  进制，分隔符为\r\n 是最优的（\\\" 与\r\n\\n 与 \\r 较少），共 ，压缩率来到 。\r\n（虽然 \r\n但是最高位的数个字符都没有用上，所以没有问题，总之我也觉得挺神奇的）。\r\n但是非常不幸的是，这份压缩表并不能在 Linux 上运行（只有 Western\r\nWindows-1252 能支持这个压缩表）。\r\n但是不论怎么样，这仍然是一个巨大的进步。\r\n2022/11/12 更新\r\n那怎么办呢，我没辙了。\r\n只能考虑有损压缩了（其实之前也算是有损压缩吧，虽然损失大概可以算是忽略不计）。\r\n我们有两条路径：\r\n\r\n把图像缩小。\r\n具体什么效果我不清楚，因为我走的另一条路径。\r\n调整压缩组\r\n不知道在什么精神状态下想出来的奇异方法。\r\n考虑如果我们每个压缩组都是偶数的话（其实本来想的是奇数的，因为奇数的压缩组比偶数的多，但是有一个\r\nbug 级的 \r\n所以没办法），那么我们就可以把最后一位省掉。\r\n具体的调整方法就遇到大于 \r\n的奇数就减一，然后再遇到就加回去，然后对于  强制加一。\r\n然后全部除二，你发现大部分的数都小于等于 ，所以我们整一个  进制即可。\r\n由于宽度都大于 ，所以你发现对于第一位一定恰好是一个字符表示宽度，所以可以将其后的分隔符删去。\r\n出来的图像是这样的：\r\n............####......................######..................##########..............############............################..........################..........##################..........################..........##################..........######..########............##......########..................########....................########..................########....................########..................########....................########..................########....................########..................########....................########..................########....................########..................########....................########..................########....................########..................########....................########..................########....................########..................########..........################################################################################################################################################################..\r\n但是在降噪的鼎力相助下反正是过了。\r\n\r\n然后又研究一些语法总之是压下去了，删掉了（最后）一个优化，幸好只跑了\r\n。\r\n其实可以两种压缩方法结合一下，但是我已经把整个代码压缩得少于  了，就不管了。\r\n压缩情况：\r\n\r\nWindows：，压缩率\r\n。\r\nLinux：，压缩率\r\n。\r\n\r\n最后的最后\r\n不后记了是吧。\r\n这道题作为一道大模拟写起来其实非常舒服（至少我觉得很舒服），尤其地考验了对与\r\nSTL 库、模板等 C++ 特性的理解（大概？）。\r\n但是耗时还是确实耗时的，而且万一思路不是非常好的话会寄的很难受。\r\n对于图像压缩的思考确实非常有趣，我觉得下次可以出一个给定图像，要求提交程序输出该图像，按照程序长度评分这样的题目。\r\n以下是开始的一些尝试的进程（前八份代码可读，至少本人可读）：\r\n\r\n（）提交记录\r\n（）提交记录\r\n（）提交记录\r\n（）提交记录\r\n（）提交记录\r\n（）提交记录\r\n（）提交记录\r\n（）提交记录\r\n（）提交记录\r\n\r\n\r\n（可读性解禁 ）提交记录\r\n（可读性解禁 ）提交记录\r\n\r\n\r\nLinux 下可运行的代码目前为 ：\r\n#include&lt;bits/stdc++.h&gt;#define E emplace_back#define V vector#define B back()#define P pop_back()#define O auto#define R return#define F for#define Z size()#define G[&amp;](I x,I y)#define A r[x][y]#define D if#define C(t,x)case t:u.B x##=n;break;#define p(e)F(;v.Z&amp;&amp;e;v.P){I n=u.B;u.P;switch(v.B){C(12,+)C(13,-)C(14,*)C(15,/)}}#define L else#define H(a,c)F(I a=0;a&lt;c;++a)using namespace std;using I=int;using d=float;struct _{I x,y;};struct g{I h,w=0;V&lt;V&lt;bool&gt;&gt;r,n,v;O e(I x){n.resize(h=x);F(O&amp;i:n)i.resize(w);}g(O*s){F(r.E();*s;++s)*s&lt;33?r.E(),0:r.B.E(*s&lt;46);r.P;w=r.B.Z;e(r.Z);}g(I x,I y){w=y+1;e(x+1);r=n;}g(const O*s){I p=1;O g=[&amp;](I k){F(p^=1,k+=k;k--;r.B.Z==w?r.E(),0:0)r.B.E(p);};r.E();w=*s-2;F(__uint128_t k=0;*++s;)D(*s&gt;1)k=k*124+*s-2;L D(k&lt;99)g(k),k=0;L F(;k;k/=14)g(k%14);e(r.Z);}struct z{I a,b,c,d;O k(z x){a=min(a,x.a);b=max(b,x.b);c=min(c,x.c);d=max(d,x.d);}};z m(I x,I y){z e{x,x,y,y};v[x][y]=1;H(i,3)H(j,3)D(I k=x+i-1,l=y+j-1;~k&amp;&amp;~l&amp;&amp;k&lt;h&amp;&amp;l&lt;w&amp;&amp;!v[k][l]&amp;&amp;r[k][l]==A)e.k(m(k,l));R e;}O f(O e){H(j,w)H(i,h)e(i,j);}O&amp;e(){v=n;f(G{I c=0,k,l;H(i,3)H(j,3)c+=~(k=x+i-1)&amp;&amp;~(l=y+j-1)&amp;&amp;k&lt;h&amp;&amp;l&lt;w&amp;&amp;r[k][l];A=c&gt;4;});R*this;}O s(){V&lt;g&gt;e;v=n;f(G{D(A&amp;&amp;!v[x][y])D(O[a,b,c,d]=m(x,y);(b-a)*(d-c)&gt;80){g n(b-a,d-c);n.f(G{n.A=r[x+a][y+c];});e.E(n);}});R e;}O t(O c){V&lt;_&gt;n;z o{h,0,w,0};f(G{D(A){O p=c(x,y);n.E(p);o.k({p.x,p.x,p.y,p.y});}});g e(o.b-o.a,o.d-o.c);F(O i:n)e.r[i.x-o.a][i.y-o.c]=1;R e.e();}O i(I a,I b){g e(a,b);f(G{D(A)e.r[ceil(x*a/d(h-1))][ceil(y*b/d(w-1))]=1;});R e;}d m(g&amp;x){I e=0,y=min(h,x.h)-1,z=min(w,x.w)-1;D(abs(w*x.h/d(h*x.w)-1)&lt;.3){O a=i(y,z),b=x.i(y,z);a.f(G{e+=a.A==b.A;});}R(d)e/y/z;}};V&lt;g&gt;t[16],a={\" O\u0007M&lt;\u000bh}\u001d8&gt;@rI\f\u0014\be#\u00019P54!\u0012jS+\u001ex:\u001baK\u0007K(\u0001&lt;qc\u001cgv%pQTu|877w\u000fg\u0001\u001fQ\u0012&gt;D\u0001\",\"\u001d\u0006\f\u0012\u001e/$\u0018\u001de\u0005B.p\u001aFhsL\u0001\u0006\f\u0012\u001e=:U-\u0013BK'xx\u0011k\u0011T\u0001\u000f*(\u0001R\u0001\",\"\u001eBe+\u0012-#&lt;n#8T@C(k^'\u0018\u0001RfR5\u0007#[\u0013\u000b.Oa\u001ec    -\u0004\u0014\u0001\u0006\\\"M[py(XPt\u001c T\u0001Y\u0001\",\"\u001eA|Ob.&amp;z&amp;\u0010v,2n}\u001c{\u0018@\u0001&lt;\u0004%\u0015xi)JH\u0018o60\u0002R|hJ\u0001\u00039Uoe\u0013] \u0006\u0003\u0016\u001c\\\\V \u0001\",\" \u001e0Cg`O\u0017'#QW\u000fu@b;k\u0010\u00010A r\u001b\\nI\u001c\u0017s\\n9\u0001\\\\\u0001\u0003:lg`PanJ\u0004P\u0014`U\u0001\",\"\u001e0K\\\"fi$\b\u001f_\b\u001de+_&lt;\u001faU\u00014\u0011uP=&amp;h\u001dZH\u0007\u001eG\\\\K\u0013^j\u0001\u0011ON\u0002X\u0015n\u000eH\u0001\",\"\u001fGe\u001f\u0010}\u0011f\u0002\u0014\\\"i,w+rK?6\u0001E|\u0003\u0001\u0010\u0001\u0012wA8;:63\u001e\u0007dsl\u000f[E\u0014u\u0001\u0005UY%X$!)\u0019\u0002\u001a\u001a\u0001\",\"\u001e\u0001U\u0001*?r\u0015\u0005rM3+SE\u0014\bh\\\"wIU\u0001&lt;\u0004%\u0012R\\\\\u001e\u00114DAZ\u0007WC(]6\u0001\\n\u0002_7iZW@]\u0001\",\"\u001e6N`f&lt;Y\t\fA2\u0013G`v.\u000bd\u001b\u0001B\u000f&amp;\u0013na%k/\u0017a6_`$^3\u0016\u0001&lt;b#UC5O[dDDh4\u0019\u001e&gt;tG\u0001\u000fk\u001e\u0001\",\"\u001eO\u0007\\r4ZWd\u0014pY1'KeLog8\u00014\u0011\u00191&gt;\u0011|R\u0003-Ih[4['mO\u0001\u0004\u0006\u001dv\u001cs7G\b=\u0016,\u00057[9x\u0001\",\"\u0017P\u001eh5o2m_1iy^r)A/v\u001d\u000190Ztwp+j2\u0006S\u0003BFt:oN\u0001P\u0018\u00199_\f8ZL\u0017aN\u0011iNg)5\u0001\f/D[\u0017\u0001\",\"\u0017P\u001em,U'9),;c\f*}XO%\u0013\u00018@gNUGo\\\\4=D:p{qO*\u0010\u0001CuiPuMf=e-wl@Zqj\u0004$\u0001\f+k@K\u0001\",\"\u001d\u0006\u0019U=)Aef15RI\u0001`\u0001 hZTovrWc_\u0003#\u0001\",\"\u001e\u0001c\u0001\",\"\u001c\u0003Lzh7&lt;@\u001d,v\u00179C\u0001:\u0001)NvBw\u0014b0#d\u001aJ8/\u0011\u001a_S\u0001\u00054O\u0001\",R\"(\u001e\u0006\u0013*\u0018|#ztFb\tg`3}^&lt;\t\u0001\u0005#7\u001dpoL\u001e\u0010*K\\\u0007|gVrL\u0001\u0006\u0013nd4}\u001c*Wvcvg4\\t\u0001fN:\u0001)\"};I w=0,z=0,c;V&lt;I&gt;u,v;char b[1&lt;&lt;21];I main(){scanf(\"%*d%*d%*d \");fread(b,1,2e6,stdin);H(i,16)H(j,31){d r=(j-15)*acos(-1)/180,c=cos(r),s=sin(r);O e=a[i].t(G{R _{x*c+y*s,y*c-x*s};});F(d a:{-.1,.1})F(d b:{-a,a})t[i].E(e.t(G{R _{x+y*b,y+x*a};}));t[i].E(e);j+=2;}F(O&amp;i:g(b).e().s()){d m=0;H(j,16)F(O&amp;k:t[j])D(d p=i.m(k);p&gt;m)m=p,c=j;D(c&lt;10)w=w*10+c,z=1;L{D(z)u.E(w),z=w=0;D(c&gt;10)p((c&lt;14||v.B&gt;13)&amp;&amp;v.B&gt;10)c==11?v.P,0:v.E(c);}}D(z)u.E(w);p(1)cout&lt;&lt;u.B&lt;&lt;endl;}\r\n\r\n2022/10/27: 之前的代码出了问题，见谅，现在这个能通过所有数据。\r\n2022/11/12: 该代码的提交记录，AtCoder\r\n计算换行是按照 \r\n计算的，但这不影响我们冲进 。\r\n\r\nWindows 下可运行的代码目前为 ：\r\n#include&lt;bits/stdc++.h&gt;#define E emplace_back#define V vector#define B back()#define P pop_back()#define O auto#define R return#define F for#define Z size()#define G[&amp;](I x,I y)#define A r[x][y]#define D if#define C(t,x)case t:u.B x##=n;break;#define p(e)F(;v.Z&amp;&amp;e;v.P){I n=u.B;u.P;switch(v.B){C(12,+)C(13,-)C(14,*)C(15,/)}}#define L else#define H(a,c)F(I a=0;a&lt;c;++a)using namespace std;using I=int;using d=float;struct _{I x,y;};struct g{I h,w=0;V&lt;V&lt;bool&gt;&gt;r,n,v;O e(I x){n.resize(h=x);F(O&amp;i:n)i.resize(w);}g(O*s){F(r.E();*s;++s)*s&lt;33?r.E(),0:r.B.E(*s&lt;46);r.P;w=r.B.Z;e(r.Z);}g(I x,I y){w=y+1;e(x+1);r=n;}g(const O*s){I p=1,c;O g=[&amp;](I k){F(p^=1,k+=k;k--;r.B.Z==w?r.E(),0:0)r.B.E(p);};r.E();w=*s-2;F(__uint128_t k=0;c=(uint8_t)*++s;)D(c&gt;1)k=k*254+c-2;L D(k&lt;99)g(k),k=0;L F(;k;k/=14)g(k%14);e(r.Z);}struct z{I a,b,c,d;O k(z x){a=min(a,x.a);b=max(b,x.b);c=min(c,x.c);d=max(d,x.d);}};z m(I x,I y){z e{x,x,y,y};v[x][y]=1;H(i,3)H(j,3)D(I k=x+i-1,l=y+j-1;~k&amp;&amp;~l&amp;&amp;k&lt;h&amp;&amp;l&lt;w&amp;&amp;!v[k][l]&amp;&amp;r[k][l]==A)e.k(m(k,l));R e;}O f(O e){H(j,w)H(i,h)e(i,j);}O&amp;e(){v=n;f(G{I c=0,k,l;H(i,3)H(j,3)c+=~(k=x+i-1)&amp;&amp;~(l=y+j-1)&amp;&amp;k&lt;h&amp;&amp;l&lt;w&amp;&amp;r[k][l];A=c&gt;4;});R*this;}O s(){V&lt;g&gt;e;v=n;f(G{D(A&amp;&amp;!v[x][y])D(O[a,b,c,d]=m(x,y);(b-a)*(d-c)&gt;80){g n(b-a,d-c);n.f(G{n.A=r[x+a][y+c];});e.E(n);}});R e;}O t(O c){V&lt;_&gt;n;z o{h,0,w,0};f(G{D(A){O p=c(x,y);n.E(p);o.k({p.x,p.x,p.y,p.y});}});g e(o.b-o.a,o.d-o.c);F(O i:n)e.r[i.x-o.a][i.y-o.c]=1;R e.e();}O i(I a,I b){g e(a,b);f(G{D(A)e.r[ceil(x*a/d(h-1))][ceil(y*b/d(w-1))]=1;});R e;}d m(g&amp;x){I e=0,y=min(h,x.h)-1,z=min(w,x.w)-1;D(abs(w*x.h/d(h*x.w)-1)&lt;.3){O a=i(y,z),b=x.i(y,z);a.f(G{e+=a.A==b.A;});}R(d)e/y/z;}};V&lt;g&gt;t[16],a={\" \u001bC­‡\u001bj7sÙ?§\u0013äjç\u0001\u0014&gt;˜Ò1~\u0005ÜÏo$Ê\u001b¬¤ø\u0001\u0015PÑ¤°JÜN=ð­ßÊÄ¡É\u0001\u0003¯š8ø\u0001\",\"\u001d\u0003Wãï³±ïÍ\u000bj´x›Þ¡^\u0001\u0003Wãð\u0007Œa—É7#p]OÂ\u0001\u0005.¤\u0001R\u0001\",\"\u001e\u0017@\u0017uÄÜÁœbx³¾A«j\u0001\u001cQê)ñ\u001c\u0011\u0018-£N£\u001aX\u00014gÍ\u001bšVéó&lt;ò\f\u0001Y\u0001\",\"\u001e\u0016úv\u0010X7ÉÙc‹ƒ6.%¡*\u0001\u0015\u0007Iän($\u0013†Ö^\u0005fáØ\u0001\u0006\u0017\u0010G÷†Ô/ú\u001d`nÈ\u0001\",\" \u000bNÚ\u0018_6\u0019¾    \f&lt;ð\u0006×&amp;\u0001\u0006p`¬#Q\u0006q¦l\u0005\u0001\\\\\u0001\\nlNÂ)'ê\u0004\u00116{7\u0001\",\"\u001e\u0011G±£\u001dÐ­~¾þ\\\\\u001fø¥ÅÃ\u0001\u0012pHAÚN\u0018ß@òfÖØµ8\u0001\u000eÎ„ÂwÜx\u0001\",\"\u001f\u0018âaË²\u0016`\u001a¢´Zø å\u0010\u0001\u00125q\u0001\u0010\u0001\u0007CÉKWr£»I2«R\u0003Ë[\u0001[\u0002S Iô\u0010¢ÏD\u0001\",\"\u001e\u0001U\u0001\u000fHp\u0014»\u000bÞ‹)MB\u0013\u000eÞ9\u0001\u0015\u0007IÛ\u001d\u001cq\u001b#ÍL(\u001d'x\u0001\brø•º:ý\u0001\",\"\u001e\u0013A¬x[-à^î\u0003\u0004'…-JÏ\u0001\u0017\u0006O`Ž\u0006ðä^&lt;\u0007˜Û\u0005ú~\u0001\u0015Fg¦P\u0007ï\u0011&lt;b1g&gt;õí\u0001\u0005NV\u0001\",\"\u001e\u001bCUhÝ¡qUµf|è^\u0011)Æ\u0001\u0012oÇ[ã+\u0017B6ßë&amp;Så_‰\u0001\u0003^õ\u0013ÏŸÈ0Áßlú\u001aœ\u0001\",\"\u0017\u001b¦Š»þÐ}\u001e±vÄW¯ó²Ñ\u0001\u0014)P !\\nÿ0¿©\u0019§Xéè\u0001\u001b¢\u0016¬,~WÕànÕ\u000b4¼Cc\u0001—“*Ç\u0001\",\"\u0017\u001b¦‘ƒ\\nŸ\u0017”\u001bì¡\u000bÜ9M1\u0001\u0013ÞÙÃ˜}”\u000eÁ\t\u0010Ò;&lt;\u000eø\u0001\u0017žq‘Â/è£{2bÕÅÀ\u0003N\u0001—&amp;3\u001d\u0001\",\"\u001dg­¡^yy)¯¿\u0001`\u0001\u0004ð™? ™‚ùÍu\u0001\",\"\u001e\u0001c\u0001\",\"\u001c\u0014øº˜ZÅe¨ÃÎ+\u0001:\u0001\u000eýC³=ÜŠ7øX\u0014!&amp;…&amp;K\u0001ÐS\u0001\",\"\u001e\u0003\\\\¸å¿óê§~\u0012\u0016lJ-I#\u0001\u0003\u0014E\u0006ç\u0003øïÑŠBò\u0007\tÆ\u0001\u0003]\u0019G[ÝOû?\u001d§áÇ*Q‚\u0001\u0019úÞ\u0001\"};I w=0,z=0,c;V&lt;I&gt;u,v;char b[1&lt;&lt;21];I main(){scanf(\"%*d%*d%*d \");fread(b,1,2e6,stdin);H(i,16)H(j,31){d r=(j-15)*acos(-1)/180,c=cos(r),s=sin(r);O e=a[i].t(G{R _{x*c+y*s,y*c-x*s};});F(d a:{-.1,.1})F(d b:{-a,a})t[i].E(e.t(G{R _{x+y*b,y+x*a};}));t[i].E(e);j+=2;}F(O&amp;i:g(b).e().s()){d m=0;H(j,16)F(O&amp;k:t[j])D(d p=i.m(k);p&gt;m)m=p,c=j;D(c&lt;10)w=w*10+c,z=1;L{D(z)u.E(w),z=w=0;D(c&gt;10)p((c&lt;14||v.B&gt;13)&amp;&amp;v.B&gt;10)c==11?v.P,0:v.E(c);}}D(z)u.E(w);p(1)cout&lt;&lt;u.B&lt;&lt;endl;}\r\n\r\n虽然不需要“目前”了，再也不会更新了。\r\n\r\n本当の本当に終わり\r\n后附\r\n感谢你读到这里。\r\n如果想尝试这题，以下可能有帮助。\r\n人类可读带大量注释代码（去除了压缩表，包含两种解码，为了保留最短代码原貌，有些地方不是很可读）：\r\n#include&lt;bits/stdc++.h&gt;using namespace std;struct image{    int h,w=0;    vector&lt;vector&lt;bool&gt;&gt; raw,null,vis;    void empty(int x){    // 初始化 null 数组        null.resize(h=x);        for(auto &amp;i:null) i.resize(w);    }    image(auto *s){    // 从字符集直接构建图片        for(raw.emplace_back();*s;++s)            *s&lt;33?raw.emplace_back(),0                :raw.back().emplace_back(*s&lt;46);        // 最后一行会多一个换行，将其弹出        raw.pop_back();        w=raw.back().size();        empty(raw.size());    }    image(int x,int y){    // 从长宽构建图片        w=y+1;        empty(x+1);        raw=null;    }    image(const auto *s){        int p=1,c;        // 处理单个压缩组        auto get=[&amp;](int k){            for(p^=1,k+=k;k--;                raw.back().size()==w?                    raw.emplace_back(),0:0)                raw.back().emplace_back(p);            };        raw.emplace_back();        w=*s-2;        // For Linux version        for(__uint128_t k=0;*++s;)            if(*s&gt;1)k=k*124+*s-2;    // 124 进制，分隔符为 1            else if(k&lt;99)get(k),k=0;            else for(;k;k/=14)get(k%14);        // For Windows version        for(__uint128_t k=0;c=(uint8_t)*++s;)    // 注意这里需要将 char 强转为 unsigned char            if(c&gt;1) k=k*254+c-2;    // 254 进制，分隔符为 2            else if(k&lt;99) get(k),k=0;            else for(;k;k/=14) get(k%14);        empty(raw.size());    }    struct out{    // 图像边缘类        int a,b,c,d;        // a 表示 x 轴左边缘        // b 表示 x 轴右边缘        // c 表示 y 轴下边缘        // d 表示 y 轴上边缘        void add(out x){            a=min(a,x.a);            b=max(b,x.b);            c=min(c,x.c);            d=max(d,x.d);        }    };    out find(int x,int y){    // 遍历连通块，返回其四边范围        out re{x,x,y,y};        vis[x][y]=1;        for(int i:{-1,0,1})            for(int j:{-1,0,1})                if(int k=x+i,l=y+j;                    ~k&amp;&amp;~l&amp;&amp;k&lt;h&amp;&amp;l&lt;w&amp;&amp;!vis[k][l]&amp;&amp;raw[k][l]==raw[x][y])                    re.add(find(k,l));        return re;    }    template&lt;typename T&gt;void foreach(T func){    // 遍历整个图像        // 注意这里的遍历顺序是先列后行，这是为了分离图像的时候也能使用这个 API        for(int j=0;j&lt;w;++j)            for(int i=0;i&lt;h;++i)                func(i,j);    }    image&amp; reno(){    // 降噪        vis=null;        foreach([&amp;](int x,int y){            int c=0,k,l;            for(int i:{-1,0,1})                for(int j:{-1,0,1})                    c+=~(k=x+i-1)&amp;&amp;~(l=y+j-1)&amp;&amp;k&lt;h&amp;&amp;l&lt;w&amp;&amp;raw[k][l];            raw[x][y]=c&gt;4;});        return *this;    }    vector&lt;image&gt; split(){    // 分离图像        vector&lt;image&gt; re;        vis=null;        // 注意如果 foreach 是先行后列的，那么这里就不能使用，必须先列后行        foreach([&amp;](int x,int y){            if(raw[x][y]&amp;&amp;!vis[x][y])                if(auto [a,b,c,d]=find(x,y);(b-a)*(d-c)&gt;80){    // 如果联通块过小，放弃                    image now(b-a,d-c);                    // 遍历整个矩形范围，然后 copy                    now.foreach([&amp;](int x,int y){now.raw[x][y]=raw[x+a][y+c];});                    re.emplace_back(now);                }});        return re;    }    template&lt;typename T&gt;image trans(T c){    // 根据给定函数进行图像变换        vector&lt;pair&lt;int,int&gt;&gt; point;        out side{h,0,w,0};        foreach([&amp;](int x,int y){            if(raw[x][y]){                pair&lt;int,int&gt; p=c(x,y);                point.emplace_back(p);                side.add({p.first,p.first,p.second,p.second});    // 把四边记录下来            }});        // 将所有点整体位移至合法范围，然后放入新图中        image re(side.b-side.a,side.d-side.c);        for(auto i:point)            re.raw[i.first-side.a][i.second-side.c]=1;        return re.reno();    // 最后降噪    }    auto fit(int a,int b){    // 将图像缩放为给定大小        image re(a,b);        foreach([&amp;](int x,int y){            if(raw[x][y])                re.raw[ceil(x*a/float(h-1))][ceil(y*b/float(w-1))]=1;        });        return re;    }    float match(image&amp; x){    // 对给定图像进行匹配，返回实数作为匹配率        int re=0,y=min(h,x.h)-1,z=min(w,x.w)-1;        if(abs(w*x.h/float(h*x.w)-1)&lt;.3){    // 对于长宽差异过大，放弃            auto a=fit(y,z),b=x.fit(y,z);    // 变换为同一长宽            // 暴力匹配            a.foreach([&amp;](int x,int y){re+=a.raw[x][y]==b.raw[x][y];});        }        return(float)re/y/z;    // 其实这里的 y,z 应该加一的，所以这样会有大于 1 的匹配率    }};vector&lt;image&gt; t[16],a={/*压缩表*/};int now=0,num=0,bestnum;vector&lt;int&gt; st0,st1;char BuF[1&lt;&lt;21];// 判断运算符号，然后将数字栈顶与下一个栈顶运算#define calc(t,x)case t:st0.back()x##=top;break;// 连续弹出符号栈直到其优先级高于自己/* 优先级为：(     0           ) + - 1           * /   2*/// 越小越高#define pops(e)\\    for(;st1.size()&amp;&amp;e;st1.pop_back()){\\        int top=st0.back();\\        st0.pop_back();\\        switch(st1.back()){\\            calc(12,+)\\            calc(13,-)\\            calc(14,*)\\            calc(15,/)\\        }\\    }int main(){    scanf(\"%*d%*d%*d \");    fread(BuF,1,2e6,stdin);    for(int i=0;i&lt;16;++i)        for(int j=-15;j&lt;16;j+=3){    // 从 -15 到 15 度，分度值为 3            float r=j*acos(-1)/180,c=cos(r),s=sin(r);            // 旋转变换            auto e=a[i].trans(                [&amp;](int x,int y){return make_pair(x*c+y*s,y*c-x*s);});            for(float a:{-.1,.1})                for(float b:{-a,a})                    // 剪切变换                    t[i].emplace_back(                        e.trans(                            [&amp;](int x,int y){return make_pair(x+y*b,y+x*a);}));            t[i].emplace_back(e);        }    for(auto &amp;i:image(BuF).reno().split()){        float bestmatch=0;        for(int j=0;j&lt;16;++j)            for(auto &amp;k:t[j])                if(float p=i.match(k);p&gt;bestmatch)                    bestmatch=p,                    bestnum=j;        // bestnum 对应字符为 \"0123456789()+-*/\"[bestnum]        if(bestnum&lt;10) now=now*10+bestnum,num=1;        else{            // 如果有数字，将其压入栈            if(num)                st0.emplace_back(now),                num=now=0;            // 如果不是左括号，尝试弹栈            if(bestnum&gt;10)                pops((bestnum&lt;14||st1.back()&gt;13)&amp;&amp;st1.back()&gt;10)            // 如果是右括号，把栈顶的左括号弹出，否则入栈            bestnum==11?                st1.pop_back(),0:                st1.emplace_back(bestnum);        }    }    if(num) st0.emplace_back(now);    pops(1)    // 全部弹栈    cout&lt;&lt;st0.back()&lt;&lt;endl;}\r\n数据生成器（可以生成单个字符，并进行测试，注意需要调整被测试代码直接输出匹配字符串）：\r\n#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;string&gt;#define cmin(x,y) if(x&gt;y) x=y;#define cmax(x,y) if(x&lt;y) x=y;#define eb emplace_backusing namespace std;using db=double;using uni=unsigned long long;const int FSIZE=1&lt;&lt;26,INF=0x7fffffff,fx[8][2]={{1,0},{0,1},{-1,0},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};const db pi=acos(-1);struct image{    int rx,ry;    vector&lt;vector&lt;bool&gt;&gt; raw,null,vis;    image(int x,int y){        raw.resize(rx=x+1);        ry=y+1;        for(int i=0;i&lt;=x;++i) raw[i].resize(y+1);        null=raw;    }    image(initializer_list&lt;uni&gt; v){        int i=0;bool p=0;auto k=v.begin();        raw.resize(1);        auto get=[&amp;](int k){            for(int j=0;j&lt;k;++j){                raw[i].eb(p);                if(raw[i].size()==ry) raw.resize(++i+1);            }            p^=1;};        for(ry=*k;++k!=v.end();)            if(*k&lt;190) get(*k);            else for(uni x=*k;x;x&gt;&gt;=5) get(x&amp;31);        raw.pop_back();        null.resize(rx=raw.size());        for(int i=0;i&lt;rx;++i) null[i].resize(ry);        print();    }    auto &amp;operator[](int x){return(raw[x]);}    struct sqr{        int x0,x1,y0,y1;        void operator+=(sqr b){            cmin(x0,b.x0)cmax(x1,b.x1)            cmin(y0,b.y0)cmax(y1,b.y1)        }        void operator+=(pair&lt;int,int&gt; b){            cmin(x0,b.first)cmax(x1,b.first)            cmin(y0,b.second)cmax(y1,b.second)        }    };    template&lt;class T&gt;void foreach(T func){        for(int i=0;i&lt;rx;++i)            for(int j=0;j&lt;ry;++j) func(i,j);    }    template&lt;class T&gt;auto trans(T func){        vector&lt;pair&lt;int,int&gt;&gt; point;        sqr out={INF,-INF,INF,-INF};        foreach([&amp;](int x,int y){            if(!raw[x][y]) return;            auto p=func(x,y);            point.eb(p);            out+=p;});        image re(out.x1-out.x0,out.y1-out.y0);        for(auto i:point)            re[i.first-out.x0][i.second-out.y0]=1;        return(re);    }    auto rotate(db ang){        ang=ang/180*pi;        db csa=cos(ang),sia=sin(ang),cex=rx/2.,cey=ry/2.;        return(trans([&amp;](int x,int y){            return(make_pair((x-cex)*csa+(y-cey)*sia+cex,-(x-cex)*sia+(y-cey)*csa+cey));}));    }    auto cut(db cx,db cy){        return(trans([&amp;](int x,int y){return(make_pair(x+y*cy,y+x*cx));}));    }    auto fit(int rxt,int ryt){        db delx=(db)(rxt-1)/(rx-1),dely=(db)(ryt-1)/(ry-1);        return(trans([&amp;](int x,int y){return(make_pair(ceil(x*delx),ceil(y*dely)));}));    }    void print(){        foreach([&amp;](int x,int y){            putchar(raw[x][y]?'#':'.');            if(y==ry-1) puts(\"\");});    }};vector&lt;image&gt; charset({{30,11,8,20,12,16,16,13,18,11,20,9,22,7,24,6,10,4,10,5,9,8,9,4,8,10,8,3,9,10,9,2,8,12,8,2,8,12,8,2,8,12,8,1,8,14,16,14,16,14,16,14,16,14,16,14,16,14,16,14,16,14,16,14,16,14,8,1,8,12,8,2,8,12,8,2,8,12,8,2,9,10,9,3,8,10,8,4,9,8,9,5,10,4,10,6,24,7,22,9,20,11,18,13,16,16,12,20,8},{27,13,4,21,7,17,10,14,13,11,16,10,17,10,17,10,17,10,17,11,6,2,8,11,3,5,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,19,8,10,134,1,26},{28,9,9,16,14,11,19,8,21,6,23,5,23,5,24,4,9,6,9,4,7,9,9,3,7,10,8,3,7,10,8,3,7,10,8,3,7,10,8,4,6,10,8,19,9,19,8,19,9,18,10,17,10,17,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,5,5,6,11,5,7,4,11,6,7,3,11,7,7,2,11,8,7,1,11,9,147,1,27},{28,9,10,14,16,10,20,7,22,6,23,5,24,4,24,4,8,7,10,3,7,9,9,3,7,10,8,3,7,10,8,4,6,10,8,20,8,20,8,19,8,19,9,12,15,12,15,13,14,14,15,13,16,13,16,19,10,20,8,20,9,20,8,20,8,20,8,20,8,19,9,2,3,13,10,1,8,8,10,2,26,2,25,2,26,3,24,4,22,9,17,14,11},{30,17,5,24,7,22,8,21,9,20,10,19,11,19,11,18,12,17,13,16,14,15,15,14,16,14,8,1,7,13,8,2,7,12,8,3,7,11,8,4,7,10,9,4,7,10,8,5,7,9,8,6,7,8,8,7,7,7,180,15,8,22,8,22,8,22,8,22,8,22,8,16,20,9,21,9,21,9,21,9,21,10,20},{28,3,22,6,23,5,23,5,23,5,23,5,22,6,7,21,7,21,7,21,7,21,7,21,7,20,8,2,8,10,20,8,22,6,23,5,24,4,24,4,25,3,8,7,10,6,2,11,9,20,9,20,8,20,8,20,8,20,8,20,8,20,8,3,1,15,9,2,4,12,9,2,8,7,11,2,26,2,25,2,25,4,23,6,21,9,17,15,10},{29,20,6,18,11,15,15,12,17,10,19,9,20,8,20,8,16,12,12,16,11,18,9,19,9,20,8,20,8,21,8,21,7,4,8,10,7,2,13,6,25,4,26,3,27,2,27,2,12,6,10,1,10,9,9,1,9,11,17,13,16,13,16,13,8,1,7,13,8,1,7,13,8,1,8,11,9,1,9,9,9,3,10,5,11,4,25,4,24,6,22,8,20,10,18,13,14,18,8},{28,0,27,1,139,1,7,11,9,1,7,11,9,1,7,10,9,2,7,10,9,2,7,10,8,3,7,9,9,3,7,9,8,4,7,8,9,5,5,9,9,19,8,19,9,19,8,19,9,19,8,19,9,19,9,19,8,19,9,19,8,19,9,19,8,20,8,19,8,20,8,19,9,19,8,20,8,19,8,20,8,20,7,21,7,23,5},{28,10,9,17,13,13,17,10,19,8,21,6,23,5,23,5,9,5,9,4,9,7,9,3,8,9,8,3,8,9,8,3,8,9,8,3,8,9,8,3,8,9,8,4,8,7,8,5,9,5,9,6,21,8,19,10,17,11,17,9,21,6,23,4,9,6,10,2,8,10,8,2,8,10,17,12,16,12,16,12,16,12,17,10,18,10,9,1,10,6,10,2,26,3,24,4,24,5,22,7,20,10,16,15,10},{28,9,9,17,13,13,17,10,19,8,21,6,23,4,24,4,10,6,9,3,9,8,9,1,9,10,8,1,8,12,7,1,8,12,7,1,8,12,16,12,16,12,17,10,9,1,8,9,10,1,10,6,11,2,26,2,26,3,25,4,24,6,12,2,8,8,8,4,7,21,7,20,8,20,8,19,8,19,9,17,10,16,12,12,15,8,19,8,19,9,18,10,16,12,14,14,12,17,6},{21,15,4,16,6,13,8,12,10,10,11,9,12,8,12,8,11,9,11,9,11,10,10,10,10,11,9,11,9,12,8,12,9,12,8,12,9,12,8,13,8,13,8,12,9,12,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,14,8,13,8,13,8,13,9,13,8,13,9,12,9,13,9,12,10,12,9,13,9,12,10,12,11,11,11,11,11,11,12,10,11,11,10,12,9,13,7,16,4,19,1},{21,2,4,16,6,14,9,12,10,11,11,10,12,10,12,11,11,11,11,11,10,12,10,12,10,12,9,13,9,13,8,13,9,13,8,13,9,13,8,13,8,13,8,13,9,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,13,8,12,8,13,8,13,8,12,9,12,8,12,9,12,9,11,9,11,10,10,10,11,9,10,11,9,11,9,11,9,11,8,12,9,11,10,10,11,9,13,7,15,4,18,1},{27,11,5,21,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,10,189,10,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,20,7,21,5},{28,1,26,1,140,1,32},{26,11,4,21,6,20,7,18,8,18,8,19,7,19,6,11,5,4,6,5,4,2,6,3,6,3,16,2,5,1,24,1,62,1,24,7,14,15,8,17,11,14,13,11,8,1,7,9,8,2,8,8,8,2,9,6,8,4,8,6,8,4,8,7,7,5,7,8,5,6,6,10,3,9,2},{28,22,4,24,6,21,7,21,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,21,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,8,20,7,20,8,20,7,20,8,20,7,20,8,20,7,22,6,23,5}});image out(60,40);char charname[17]=\"0123456789()+-*/\";#include&lt;random&gt;#include&lt;chrono&gt;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());int main(){    for(;;){        freopen(\"AT678.in\",\"w\",stdout);        printf(\"0 0 0\\n\");        int p=rnd()&amp;15;        image i=charset[p];        uniform_real_distribution&lt;&gt; R1(0.9,1);        uniform_real_distribution&lt;&gt; R2(-.1,.1);        db a=R1(rnd),b=R1(rnd),c=R1(rnd);        i=i.fit(i.rx*a,i.ry*a);//        i.print();        i=i.fit(i.rx*b,i.ry);//        i.print();        i=i.fit(i.rx,i.ry*c);//        i.print();        i=i.rotate(uniform_real_distribution&lt;&gt;(-18,18)(rnd));//        i.print();        i=i.cut(R2(rnd),R2(rnd));//        i.print();        out=image(60,40);        i.foreach([&amp;](int x,int y){            out[x+5][y+5]=i[x][y];        });        out.foreach([&amp;](int x,int y){            if(!uniform_int_distribution&lt;&gt;(0,19)(rnd))                out.raw[x][y]=!out.raw[x][y];        });        out.print();        fclose(stdout);        freopen(\"\",\"w\",stdout);        printf(\"%c\\n\",charname[p]);        system(\"AT678_s4tmp &lt; AT678.in &gt; AT678.out\");        freopen(\"AT678.out\",\"r\",stdin);        if(getchar()!=charname[p]){            exit(1);        }    }}\r\n","categories":["Solution"],"tags":["Bruce Force"]},{"title":"CF1707E Replace","url":"/post/CF1707E/","content":"题意\r\n给定长度为  的序列 ，与  个询问求以下函数的返回值：\r\nf(l,r)=    if 1==l &amp;&amp; r==n        return 0    else        return f(min{A[l]...A[r]},max{A[l]...A[r]})+1\r\n\r\n思路\r\n首先需要一个重要的性质：若干个相交的区间迭代相同次数的  得到的若干区间仍然是相交的。\r\n这个可以通过两个区间的情况以及一次迭代归纳证明。\r\n可以进一步推广：迭代后的区间并等于迭代前的区间的并的迭代。\r\n这个是显然的，因为第一次迭代之后是全相交的，那么必然连续。因为最小最大值的可重复贡献以及结合律，迭代一次必然相等，然后归纳即可。\r\n那么就可以考虑将区间拆成 \r\n的形式，这样区间个数就只有 \r\n个了，只要维护出这 \r\n个区间按照迭代次数倍增的结果即可二分迭代次数求出答案。\r\n显然直接按照定义式转成 RMQ 问题即可。\r\nCODE\r\n这题如果写一般的单  RMQ 是\r\n 的，会有点卡常。\r\n这里写了线性 RMQ，时间复杂度为 。\r\n需要注意区间退化成单点的情况，这里的实现是直接再倍增了一个数组。\r\n#include&lt;cstdio&gt;#include&lt;functional&gt;using namespace std;const int N=100010,M=18,FSIZE=1&lt;&lt;26;int n,m,p[M][N],a[M][N],b[M][N];template&lt;typename T&gt;struct RMQ{    int n,A[N],BS,S[M][N/(M-1)],in[N],Pos[N],Pre[N],Sub[N],F[N];    int max(int x,int y){return(T()(x,y)?x:y);}    void buildST(){        for(int i=0;i&lt;n;++i){            in[i]=i/BS;            if(!(i%BS)) S[0][in[i]]=0x7ffffff-max(0,0x7ffffff);            S[0][in[i]]=max(S[0][in[i]],A[i]);            Pos[i]=i&amp;&amp;in[i-1]==in[i]?Pos[i-1]+1:0;        }        for(int i=1,t=(n-1)/BS;i&lt;=31-__builtin_clz(t);++i)            for(int j=1;j+(1&lt;&lt;i)-1&lt;=t;++j)                S[i][j]=max(S[i-1][j],S[i-1][j+(1&lt;&lt;(i-1))]);    }    void buildSubPre(){        for(int i=0;i&lt;n;++i)            Pre[i]=i&amp;&amp;in[i]==in[i-1]?max(Pre[i-1],A[i]):A[i];        for(int i=n-1;~i;--i)            Sub[i]=in[i]==in[i+1]?max(Sub[i+1],A[i]):A[i];    }    void buildBlock(){        static int S[N],top;        for(int i=0;i&lt;n;++i){            if(!i||in[i]!=in[i-1]) top=0;            else F[i]=F[i-1];            while(top&amp;&amp;T()(A[i],A[S[top]])) F[i]^=1&lt;&lt;Pos[S[top--]];            F[S[++top]=i]|=1&lt;&lt;Pos[i];        }    }    void init(int *a,int _n){        if(!(n=_n)) return;        for(int i=0;i&lt;n;++i) A[i]=a[i];        BS=(31-__builtin_clz(n))*1.5;        buildST();        buildSubPre();        buildBlock();    }    int query(int l,int r){        int bl=in[l],br=in[--r];        if(bl!=br){            int ans=max(Sub[l],Pre[r]);            if(br-bl&gt;1){                int p=31-__builtin_clz(br-bl-1);                ans=max(ans,max(S[p][bl+1],S[p][br-(1&lt;&lt;p)]));            }            return(ans);        }        return(A[l+__builtin_ctz(F[r]&gt;&gt;Pos[l])]);    }};RMQ&lt;less&lt;int&gt;&gt; R0[M];RMQ&lt;greater&lt;int&gt;&gt; R1[M];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}void build(int t){    for(int i=0;i&lt;n;++i) p[t][i]=p[t-1][p[t-1][i]];    for(int i=0;i&lt;n-1;++i){        if(a[t-1][i]&lt;b[t-1][i]){            a[t][i]=R0[t-1].query(a[t-1][i],b[t-1][i]);            b[t][i]=R1[t-1].query(a[t-1][i],b[t-1][i]);        }else a[t][i]=b[t][i]=p[t-1][a[t-1][i]];    }    R0[t].init(a[t],n-1);    R1[t].init(b[t],n-1);}int query(int l,int r){    int re=0;    for(int i=M-1;~i;--i){        int x=R0[i].query(l,r),y=R1[i].query(l,r);        if(0&lt;x||y+1&lt;n){            l=x;            r=y;            re+=1&lt;&lt;i;        }        if(l==r) return(1&lt;&lt;18);    }    return(re+1);}int main(){    fread(BuF,1,FSIZE,stdin);    read(n);read(m);    for(int i=0;i&lt;n;++i) read(p[0][i]);    for(int i=0;i&lt;n-1;++i){        a[0][i]=min(p[0][i],p[0][i+1])-1;        b[0][i]=max(p[0][i],p[0][i+1])-1;    }    R0[0].init(a[0],n-1);    R1[0].init(b[0],n-1);    for(int i=1;i&lt;M;++i) build(i);    for(int i=1,l,r;i&lt;=m;++i){        read(l);read(r);        if(l==1&amp;&amp;r==n){            printf(\"0\\n\");            continue;        }        if(l&lt;r){            int ans=query(l-1,r-1);            if(ans==1&lt;&lt;18) ans=-1;            printf(\"%d\\n\",ans);        }else printf(\"-1\\n\");    }    return(0);}\r\n","categories":["Solution"],"tags":["Data Structure"]},{"title":"CSP 2021","url":"/post/CSP-2021/","content":"DAY 0-14i~0-7i\r\n学习奇怪的 \r\nRMQ，口胡了一个奇怪的分块线性 RMQ ，似乎询问比用 ST 表的快。\r\nDAY 0-4i\r\n顺手学习了标准 RMQ ，似乎没什么用的样子。\r\n不过可以装 13\r\nDAY 0-2i\r\n写了写 RMQ 的总结，然后无心复习初赛，腐了一晚上泰讯。\r\nDAY 0+1i\r\n是的我们没有公元零年\r\n早上遇见了 LH 大佬，众人表示他已经 AK 了 3\r\n场模拟，并让他在成绩表上弄个 400.\r\nTG 卷子一发我直接先笑了 5min .\r\n\r\n哟，这不是约束 RMQ 嘛，这才两天不见……\r\n\r\n中途猜测 \r\n花了一段时间，意识到自己根本猜不出来。\r\n不过我们可以猜球的体积公式，然后一波反推，嗯是  ，然后就可以勉强做了。\r\n然后被 Base64 卡了一会，之前玩过这玩意但是没用去看原理，然后愣是通过\r\n解密/加密 的 3/4 分节猜出来了。\r\n\r\nCCF 你好家伙，这 ‘W’ 要小写。\r\n\r\n约束 RMQ 喜闻乐见的送分。\r\n中午遇见了第一次打 CSP 的 YWQ，他表示不大行。\r\n与 WZX 吃了快乐的\r\n虽然好吃但是真贵以及旁边还有小情侣秀恩爱的那种 午餐之后，WZX\r\n去买纸巾，然后我们发现了……\r\nCCF 提供的餐厅……\r\n\r\n没关系午饭是真的好吃绝对抵得上饭钱……\r\n\r\n中午与 LZC 讨论发现我把线段树的时间复杂度整成  的了……\r\n\r\n可是你两天前才写过线段树是 \r\n啊喂。\r\n\r\n不过没关系 LZC\r\n也挂了而且他刚跟别人讲过线段树的时间复杂度，所以我心里真的很平衡\r\n安静前前面有不知名华附学生与不知名小学生若干在玩狼人杀。\r\n可恶，我怎么没有把饭给带进来\r\n下午的倒是没有什么特别的。\r\n除了 CCF 专业摆烂直接把上午的代码放到的下午来。\r\n\r\n不能说是十分相似只能说它完全就是。\r\n\r\nDAY 0+3i\r\nLuogu 出 ans 力，把提高最后六题对完就没什么想法了。\r\n就已经过了\r\nDAY 1+1i\r\n上午还是非常平凡的。\r\n今年的普及组质量好像没有去年好。\r\n疯狂 STL 就行。\r\n甚至开始睡起来\r\n下午的 T1 比较简单，STL 随便写写。\r\n然后 T2 写了 2h 没有分，被去重搞死。\r\nT3 0.5h 应该糊出了正解，不是很清楚。\r\n然后就结束了。\r\n出考场心态大崩，T3 数组只开了十万。\r\nDAY 1+2i\r\n猛然发现 T2 去重明明很好写，转移加一个限制就行。\r\n意识到自己在考场上想码 \r\n做法就跟 SB 一样。\r\nDAY 1+3i\r\n好像都炸掉了，莫名其妙的。\r\n人已经自闭了，失去理智的。\r\n感觉自己要退役了，什么垃圾\r\n校内 OJ 以奇异的方式在我 JY 这台机子上不可用，果然 JY 什么垃圾。\r\n还是等周末去 JZ 吧。\r\n不过校内 OJ 数据挺拉的。\r\n我只要去别的地方测统统没分\r\nDAY 1+5i\r\npalin 过了，什么智障错误。\r\nans[1]=...\r\n但它是从 0 开始的。\r\nDAY 1+7i\r\n校内讨论，负责 T3。\r\nDAY 1+11i\r\n西西艾夫数据水上天，送了我一个 AK。\r\n好。\r\n提高没什么意外，与 LOJ 分数几乎一致。\r\n要是提高 T2 T3 换一下我应该会多不少，各种各样的问题多了去了。\r\n","categories":["Record"],"tags":["CSP","Log"]},{"title":"CSP 2022","url":"/post/CSP-2022/","content":"DAY 0+i\r\n上午不用打普及，在机房有些颓废，出题出的非常寄。\r\n快润的时候机房里讨论起普及卷子，非常有趣，C 与 PASCAL\r\n退役之后开始考一大堆 C++ 特性了。\r\n下午起床用 5min 快速水了一下 cppreference。\r\n进考场略有点晚。\r\n然后找了会座位，然后宣读了老半天要收健康码甚么的。\r\n但是教练没发.jpg\r\n没关系主场作战一点不慌。不慌就有鬼了\r\n看到卷子，T1 四个选项非常熟悉。\r\n然后三叉树手枚了个 98。\r\n然后卡在了分组，我 DP 了一遍，差不多又枚了一遍找规律全是 105。\r\n心态大崩.jpg\r\n嘶，我寻思怎么这么小呢。\r\n约开题 30min 后：这不会是从 8 个人里选择 2\r\n个人出来其他人不管了吧？\r\n好像没甚么问题。\r\n作为一个卡常人基数排序我老熟了好吧，就是这个  有点诡异，由于  不是变量于是决定叉掉。\r\n然后被 ans[m++]=(n%(-k)+k)%k 卡住了，我发现\r\n100 7 手模不出来，约 30min 后弃疗。\r\n发现后面的程序补全甚么彩笔玩意。\r\n然后回来，开始模拟 1000000 19\r\n（？）然后至少对了一位。\r\n\r\n这选项这意思是不是就是进制转换啊？\r\n\r\n然后就开始对着这个嗯直接选，负数就胡乱模了一下好像是那么回事。\r\n然后想想好像  是对的。\r\n然后回去检查发现三叉树的 98 模寄了，于是规律了一下选了 97。\r\n出来之后：\r\n\r\n加一怎么可能对啊，负数的话还要再加一位。\r\n\r\n有道理，我是彩笔。\r\n晚上反转了，它有一个愚蠢的 。\r\nLG 估分 86.5。\r\nDAY 0+7i\r\n有一个来源不明的神秘答案又反转了，但我寻思假的。\r\n得，成绩出来了，多了 4.5pts，答案有点东西的。\r\nDAY 1+i\r\n开场 20min 看完四题，感觉能切两题，感觉良好。\r\nT1 码 10min 之后发现分层 DP 假了，5min 之后观察到选择 4\r\n个点想到正解，调整做法。\r\n大概在 15:18 过完样例。\r\n然后 20min 切掉 T2 开始看 T3，花了 10min\r\n看懂并转化完题意然后又想了一会没什么思路，码了 60pts 就润了。\r\nT4 一次开题的时候以为  跟  同阶，感觉巨不可做，第二次发现 ，手玩发现跳出链只有一种情况，是很好想的\r\nDDP。\r\n然后写了倍增，调了 2.5h 写了 4.6k 拿到了 0pts。\r\nDAY 1+3i\r\n测完发现 T1 挂了一个小细节，应该不会掉太多分。\r\n但是 T3 整个写挂了，没了 45pts。但是几乎等价于全 NO\r\n能把学军数据水掉。\r\n有点难受。\r\nDAY 1+10i\r\n100+100+35+0=235pts\r\n寄了。\r\n总结\r\n大于 3k\r\n的正解还是小心谨慎，尤其是暴力没写并且其他题还没检查的时候。\r\n正在练习肉查能力。\r\n","categories":["Record"],"tags":["CSP","Log"]},{"title":"通信题杂记","url":"/post/Communicate-Problem/","content":"很早就知道 UOJ454 了。\r\n今天终于决定写。\r\n然后发现通信题的运行调试很麻烦，在各种尝试后终于找到了可以正常运行的方法，而且不需要外部辅助。\r\n把读入写成这样：\r\nchar read(){    char re=getchar();    for(;re==-1;re=getchar());    return(re);}\r\n这样读完就会自动等待对面输出。\r\n然后文操这么写：\r\n//Alicesystem(\"del B.out\");            //清空文件freopen(\"A.out\",\"w\",stdout);    //创建标准输出文件while(access(\"B.out\",0)==-1);   //等待对方创建标准输出文件，否则在无文件的情况下会直接卡死freopen(\"B.out\",\"r\",stdin);//重定向标准输入，这一行的位置必须位于确认文件存在之后\r\n//Bobsystem(\"del A.out\");//同上。因为两个程序会先后开，所以先开的那个会把文件占用，后开的删不掉freopen(\"B.out\",\"w\",stdout);while(access(\"A.out\",0)==-1);freopen(\"A.out\",\"r\",stdin);\r\n需要使用 #include&lt;unistd.h&gt; 头文件。\r\n然后就可以正常运行了。\r\n附UOJ454 AC代码：\r\n//Alice#include&lt;iostream&gt;#include&lt;unistd.h&gt;#include&lt;cstdlib&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;ifstream fin;char read(){    char re=getchar();    for(;re==-1;re=getchar());    return(re-48);}void write(int ch){    putchar(ch+48);    fflush(stdout);}int n,m,k=0,te;bool s[2010],need[2010];char c;int main(){//  #define DEBUG#ifdef DEBUG    system(\"del B.out\");    freopen(\"A.out\",\"w\",stdout);    while(access(\"B.out\",0)==-1);    freopen(\"B.out\",\"r\",stdin);#endif        fin.open(\"alice.in\");    fin&gt;&gt;n&gt;&gt;m;    te=(n&lt;&lt;1)/3;    for(int i=1;i&lt;=n&lt;&lt;1;++i){        fin&gt;&gt;c;        s[i]=c-48;    }    k=read()&lt;&lt;1;k+=read();    for(int i=1;i&lt;=te;i++){        write(s[i+k*te]);    }    for(int i=1;i&lt;=te;i++){        if(read()){            write(s[i+(k?0:te)]);        }    }    for(int i=1;i&lt;=te;i++){        if(read()){            write(s[i+(k&lt;2?te&lt;&lt;1:te)]);        }    }    for(int i=te*3+1;i&lt;=n&lt;&lt;1;i++){        write(s[i]);    }    return(0);}\r\n//Bob#include&lt;iostream&gt;#include&lt;unistd.h&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;ifstream fin;char read(){    char re=getchar();    for(;re==EOF;re=getchar());    return(re-48);}void write(int ch){    putchar(ch+48);    fflush(stdout);}ofstream fout;int n,m,te,a[2010],s[3],k;bool p[2010],ans[2010];int main(){//  #define DEBUG    #ifdef DEBUG    system(\"del A.out\");    freopen(\"B.out\",\"w\",stdout);    while(access(\"A.out\",0)==-1);    freopen(\"A.out\",\"r\",stdin);    #endif        fin.open(\"bob.in\");    fout.open(\"bob.out\");    fin&gt;&gt;n&gt;&gt;m;    te=(n&lt;&lt;1)/3;    for(int i=1;i&lt;=n;++i){        fin&gt;&gt;a[i];        p[a[i]]=1;    }    for(int i=1;i&lt;=te;i++){        s[0]+=p[i];s[1]+=p[i+te];s[2]+=p[i+(te&lt;&lt;1)];    }    k=s[0]&gt;s[1]?0:1;    k=s[k]&gt;s[2]?k:2;    write(k&gt;&gt;1);write(k&amp;1);    for(int i=1;i&lt;=te;i++){        ans[i+k*te]=read();    }    for(int i=1;i&lt;=te;i++){        write(p[i+(k?0:te)]);        if(p[i+(k?0:te)]){            ans[i+(k?0:te)]=read();        }    }    for(int i=1;i&lt;=te;i++){        write(p[i+(k&lt;2?te&lt;&lt;1:te)]);        if(p[i+(k&lt;2?te&lt;&lt;1:te)]){            ans[i+(k&lt;2?te&lt;&lt;1:te)]=read();        }    }    for(int i=te*3+1;i&lt;=n&lt;&lt;1;i++){        ans[i]=read();    }    for(int i=1;i&lt;=n;i++){        fout&lt;&lt;ans[a[i]];    }    return(0);}\r\n","categories":["Note"],"tags":["Non-Traditional Problem"]},{"title":"多项式卷积： FFT/NTT/MTT","url":"/post/FFT/","content":"upd 2021/8/12：\r\n修复缩进，大量更改了一些刷新我认知的东西。\r\nupd 2022/3/9： 修代码与排版。\r\nLZC\r\n大佬表示多项式应该先学生成函数等等我不会的东西，所以别看了。\r\n以下 99% 的内容没有证明，也不会用很标准的数学形式，只可意会。\r\n由于我随时可能忘光回来复习所以特别啰嗦。\r\n所有的代码都经过了结构性优化，其实适合背板子不适合理解。\r\n代码都很短，不用担心。\r\n警告：以下所有代码都不能通过洛谷上的模板题P3803，因为数组没开够。\r\n前置知识\r\n定义\r\n设  ，则  为一个  次多项式。完完全全的废话\r\n设有一个  次多项式  与一个\r\n 次多项式 ， 与  的多项式乘法卷积为  ，则  .完完全全的废话x2\r\n反正直接理解成无限进制下整数乘法就行。\r\n复数\r\n设  为虚数单位，则\r\n（ 均为实数）为复数，其中  为该复数的实部，  为该复数的虚部。\r\n乘法即为：\r\n\r\n重要：由复数点组成的集合叫复平面（也就是把  看作为坐标 ）。\r\n所以可以定义绝对值为其到原点的距离 。\r\n其实这玩意就是平面直角坐标系，相加满足平面直角坐标系中向量加的四边形法则，相乘满足极坐标系中的辐角相加，模长相乘。\r\n反正我们只研究单位根不用管那么多。\r\n点值表示法\r\n还是那个多项式 \r\n，在学习拉格朗日插值的时候我们就知道了  个点可以确定一个  次多项式，所以\r\n\r\n可以用来表示一个 \r\n次多项式。\r\n这个玩意没有什么用处，除了一个性质：\r\n 可以表示为\r\n\r\n嗯，为什么呢，你考虑一个点意味着什么， 满足  .\r\n而我们显然有：\r\n\r\n所以：\r\n\r\n总而言之，点值表示法（满足取的点集的横坐标相等）表示的多项式相乘，直接把代入数相同的项乘起来就行。\r\nFFT\r\n\r\nFast Fourier Transform 快速傅里叶变换\r\n\r\n给出多项式  求多项式 （也就是上面提到的卷积）。\r\n\r\n这个柿子非常常见，而且看起来非常可以优化。\r\n所以对着这个柿子，我们想想考虑怎么优化。\r\n然后我们发现似乎并不能优化。\r\n所以把这个柿子扔掉吧！你看，我们可以直接把两个点值表示的多项式  乘起来！\r\n不过，因为  次多项式与  次多项式的积会有  次，所以我们的点值表示应该有至少\r\n 个点才对。当然，这仍是  的。\r\n但是这是个虚假的 ，因为这个点值表示法乘出来完全没有用。\r\n于是尝试化为一般的多项式，发现只能  插值并没有什么意义。\r\n而且由一般的多项式化为点值需要把  个点丢进去算也是  的。\r\n于是某人想出一个好主意：把一些奇怪的 \r\n带进去算点值，以使用某些性质加速运算。\r\n单位根\r\n考虑 \r\n，这样的复数有一个性质， 其若干次幂的绝对值均为1.\r\n因为辐角相加，模长相乘所以是对的，我才不会告诉你我暴力展开然后不会因式分解才这样写的\r\n这样的点将在复平面上形成一个半径为1的圆（单位圆），于是可以定义  为从点  开始逆时针旋转  个单位圆得到的点。\r\n因为辐角相加，模长相乘 ，所以 \r\n的若干次方有一个很棒的性质： 为从点  开始逆时针旋转  个单位圆得到的点。\r\n所以，当  时， 的若干次方呈：\r\n\r\nunit circle\r\n\r\n还是因为辐角相加，模长相乘 ，所以： \r\n我们惊奇的发现这就是分数！\r\n对了，这里提一个很重要的东西，\r\n。\r\n因为  是 \r\n，而显然按照我们的定义单位根应该是一整个圆即  所以乘二。\r\n接下来是两个重要的东西：\r\n周期引理\r\n\r\n我们可以感性理解一下：\r\n\r\n后面那个东西请想象一个点在圆上转了半圈所以对原点对称，记住这个负号不仅对实部取负，虚部也取负。\r\n证明到一半夭折了。\r\n以及，这样意味着我们实际使用的单位根只有 \r\n个，因为剩下的一半我们可以对已有的一半取负得到（实际上，一半的单位根用不上，这就是我们优化的基础）。\r\n其实这个式子似乎没有名字，不过有个与它相似的叫周期引理，而我主观的认为它们一致：\r\n\r\n消去引理\r\n\r\n这不就是分数的约化还要证明？\r\n另外，有的地方会提到一个折半引理：\r\n\r\n请恕我实在不明白这个东西跟消去引理的区别。\r\nDFT\r\n\r\nDiscrete Fourier Transform 离散傅里叶变换\r\n\r\n用于把多项式转换成点值表示。\r\n合着才开始呢？\r\n接下来会有一堆式子，不过这些式子在理解了复数之后并不复杂。\r\n对于  次多项式  尝试按  的次数的奇偶性拆开，变成  与  ，于是  。\r\n整理 ： \r\n现在把  中的  提出去，仍然叫  .\r\n于是原式变成了：\r\n\r\n话说我长期以为要直接对这两个柿子分治导致不会整。\r\n现在假设我们往  里面丢一个\r\n ，那么变成了：\r\n\r\n我们发现并没有什么用，于是再丢一个  进去：\r\n\r\n由于这个多项式中的 \r\n都只有偶数次幂，所以负号没有什么用，我们把负号去了：\r\n\r\n我们发现这与上面 \r\n的柿子只有一个符号不同：\r\n\r\n因为你求出了  与  之后就可以得到  与 \r\n。前两个多项式的总长为 \r\n，而后两个的总长为 \r\n。并且，这个过程可以递归进行，每轮多项式的规模缩小一半，于是总的时间复杂度为\r\n 。\r\n于是可以分治了！吗？\r\n用这种方式乘出来的东西是点值表达式，但我们还要转换回系数表达才能用。\r\n怎么做呢，我也不会\r\n总之就是把所有的 \r\n的虚部取负（或者专业一点，变为共轭复数），然后做一次完全一样的\r\nDFT ，然后除一个 \r\n就行。这个过程有一个专门的名字 IDFT\r\n（逆离散傅里叶变换）。知道就好没什么用\r\n具体的证明要扯出范德蒙德矩阵来，大家的线性代数学的比我好，反正我不会。\r\n不过还是贴一个有证明的\r\nblog好了，感兴趣可以看一看。\r\nCODE\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#define N 262145#define uni unsigned#define reg register#define lf long double#define cp(a,b) (complex{a,b})using namespace std;const lf PI=acos(-1);    //math.h中的M_PI是double精度，不够用uni n,m,lim=1,l=-1,r[N];char BuF[1&lt;&lt;26],*InF=BuF;struct complex{    lf r,i;    complex operator+(complex b){return(cp(r+b.r,i+b.i));}    complex operator-(complex b){return(cp(r-b.r,i-b.i));}    complex operator*(complex b){return(cp(r*b.r-i*b.i,r*b.i+i*b.r));}}a[N],b[N];template&lt;typename T&gt;void read(T &amp;x){    for(;47&gt;*InF||*InF&gt;58;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}void fft(complex *a,uni lim,bool mode){    if(lim&gt;1){    //当长度为1时结束分治        uni half=lim&gt;&gt;1;        complex a0[half],a1[half];        for(uni i=0;i&lt;lim;i+=2) a0[i&gt;&gt;1]=a[i],a1[i&gt;&gt;1]=a[i+1];        //按奇偶性分开        fft(a0,half,mode);fft(a1,half,mode);    //分治        for(uni i=0;i&lt;half;++i){            complex temp=cp(cos(i*PI/half),mode?-sin(i*PI/half):sin(i*PI/half))*a1[i];            //这里没有使用计算一个单位根再幂的方式而是直接计算            //这样会很慢，但精度更高，为什么要追求精度下面会提到            a[i]=a0[i]+temp;            a[i+half]=a0[i]-temp;        }    }}int main(){    fread(BuF,1,1&lt;&lt;26,stdin);    read(n);read(m);    for(reg uni i=0;i&lt;=n;read(a[i++].r));    for(reg uni i=0;i&lt;=m;read(b[i++].r));    for(;lim&lt;=n+m;++l) lim&lt;&lt;=1;    //由于要保证FFT中每一次分治都能均分，所以需要把多项式长度补充为2的幂    //注意长度要 **大于** n+m，不知道为什么的话可以回去看看点值是怎么表示多项式的    fft(a,lim,0);    fft(b,lim,0);    for(reg uni i=0;i&lt;=lim;++i) a[i]=a[i]*b[i];    fft(a,lim,1);    for(reg uni i=0;i&lt;=n+m;++i)        printf(\"%d \",(int)(a[i].r/lim+0.5));    //+0.5 的意义是四舍五入    return(0);}\r\n但这个东西没有什么用，甚至本地跑直接栈溢出。\r\n小优化\r\n考虑如何进行优化，发现 DFT\r\n在分治前除了划分奇偶啥也没干，考虑直接划分到位，自底向上。\r\n根据手玩可以发现对于位置 \r\n，其最后划分完成的数为其二进制反转。例如  这个位置最后放的是  。\r\n大致的过程就是我们把系数放到最后的位置，由下至上做 DFT ，因为 DFT\r\n的过程不会因为系数的改变而改变，所以我们中间不用再管系数是什么的问题，只需要按照流程算数就行了。\r\n这个在很多地方被称为蝴蝶变换，但是有些地方也拿蝴蝶变换指代我们分治的过程。\r\n为了防止任何的歧义，这里一个也不拿出来当名称。\r\n再提一次：有用的 \r\n一共只有 \r\n个（因为虚部为负的 \r\n个会被我们的分治优化掉，彻底用不上）。\r\n可以预处理出 \r\n个单位根减少三角函数的调用次数，而且对于一种按照定义，取  然后求幂来得到  的方式而言，精度更高。\r\n一般而言，只要你不在 \r\n的循环里面使用三角函数，（相对与  次复数乘法而言）它们对时间的影响就可以忽略不计。\r\n有些时候你会见到有些地方预处理单位根时不乘二，也即 \r\n，实际上这种方式按顺序求出来的是按照原先定义的  。\r\n不过，如果你去（把那些代码放到本地）调试看看，你会发现其中多出来的\r\n\r\n的部分根本用不上。\r\n所以下面的所有代码已经调整过了不会有这个问题，这样如果这篇文章被人看到的话，看到的人就不会像我一样被刷新认知了。\r\n以及，在上方已经使用的，手写复数代替标准库中的复数。\r\nCODE\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#define N 262145#define uni unsigned#define reg register#define lf long double#define cp(a,b) (complex{a,b})using namespace std;const lf PI=acos(-1);uni n,m,lim=1,l=-1,r[N];char BuF[1&lt;&lt;26],*InF=BuF;struct complex{    lf r,i;    complex operator+(complex b){return(cp(r+b.r,i+b.i));}    complex operator-(complex b){return(cp(r-b.r,i-b.i));}    complex operator*(complex b){return(cp(r*b.r-i*b.i,r*b.i+i*b.r));}    complex operator/(uni b){return(cp(r/b,i/b));}    complex operator~(){return(cp(r,-i));}}a[N],b[N],wn[N];template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}void dft(complex *a){    for(reg uni i=0;i&lt;lim;++i)        if(i&lt;r[i]) swap(a[i],a[r[i]]);    for(reg uni mid=1,cnt=l;mid&lt;lim;mid&lt;&lt;=1,--cnt)        for(reg uni i=mid&lt;&lt;1,j=0;j&lt;lim;j+=i)            for(reg uni k=0;k&lt;mid;++k){                complex x=a[j+k],y=wn[k&lt;&lt;cnt]*a[j+mid+k];                a[j+k]=x+y;                a[j+mid+k]=x-y;            }}int main(){    fread(BuF,1,1&lt;&lt;26,stdin);    read(n);read(m);    for(reg uni i=0;i&lt;=n;read(a[i++].r));    for(reg uni i=0;i&lt;=m;read(b[i++].r));    for(;lim&lt;=n+m;++l) lim&lt;&lt;=1;    for(reg uni i=1;i&lt;lim;++i)        r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l);    for(reg uni i=0,r=lim&gt;&gt;1;i&lt;r;++i)        wn[i]=cp(cos(i*PI/r),sin(i*PI/r));    //注意这里只求了 0~lim-1 部分的单位根    //没有乘二是因为我们已经把长度缩小了一半    //不过当然，因为是乘二除二，所以精度怎么做也不会有损失    dft(a);dft(b);    for(reg uni i=0;i&lt;lim;++i){        a[i]=a[i]*b[i];        wn[i]=~wn[i];        //这里将单位根取共轭，用于 IDFT    }    dft(a);    for(reg uni i=0;i&lt;=n+m;++i)        printf(\"%u \",(uni)(a[i].r/lim+0.5));    return(0);}\r\nNTT\r\n\r\nNumber-Theoretic Transform 数论变换\r\n这里提一下大部分地方都把 NTT 的全称写成了 (Fast) Number Theory\r\nTransform 是不对哒，维基上写的是 Number-Theoretic Transform\r\n。以及，中文名似乎也没有“快速”。\r\n\r\n总所周知大部分题目都会有模数，我们考虑是否对于一个剩余系有一些更好的东西来代替掉精度又慢的复数。\r\n答案是有的，对于一个  （这个\r\n\r\n还要满足一些性质，等一会提到）的原根  ，其满足：\r\n\r\n\r\n对了，整数 \r\n原根的定义是一个整数  满足存在一个\r\n 使得  成立且  是满足这个柿子的最小的  .\r\n当然，这个定义不拿来推柿子没什么用。反正我也不会证它为什么满足上面的性质\r\n至于怎么求原根的话，可以用 BSGS\r\n然后枚举一下，原根有个非常非常松的上界，它小于 ，不过一般出题人会用的模数原根都是\r\n3 .\r\n因为能用的模数必须满足设其表示为 （ 可以是合数，要求  最大），则  大于数据中的  （或者换种说法：满足  这里的  为调整过后的）。\r\n如果实在不放心可以在这里查 NTT\r\n能用的模数的原根。\r\n悲惹，这个 blog 木大了。现在可以看这个。\r\nCODE\r\n这个是更新的进行了常数优化的板子，能以比较好的速度完成常规要求。\r\n在 UOJ#34 上取得了恰好\r\nms 的用时，附近似乎都是 1.5 倍\r\nFFT 的提交（下面会提到，但是不会有，因为我很菜）。\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#define N 262145#define mod 998244353#define uni unsigned#define ll uni long longusing namespace std;const uni M0=0x7fffffff;uni n,m,lim=1,l=-1,r[N],a[N],b[N];uni power(uni base,uni t){    uni re=1;    for(;t;t&gt;&gt;=1,base=(ll)base*base%mod)if(t&amp;1)re=(ll)re*base%mod;    return(re);}struct pre{    uni g[N+N]={0},gi[N+N]={0};    constexpr pre(){        for(uni i=0,t=0;(t=1&lt;&lt;i)&lt;N;++i){            g[t|1]=power(3,(mod-1)/(t&lt;&lt;1));            gi[t|1]=power(3,mod-1-(mod-1)/(t&lt;&lt;1));            g[t]=gi[t]=1;            for(uni j=t+2;j&lt;t&lt;&lt;1;++j){                g[j]=(ll)g[j-1]*g[t|1]%mod;                gi[j]=(ll)gi[j-1]*gi[t|1]%mod;            }        }    }}pre;char BuF[1&lt;&lt;26],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;47&gt;*InF||*InF&gt;58;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}int main(){    fread(BuF,1,1&lt;&lt;26,stdin);    read(n);read(m);    for(uni i=0;i&lt;=n;read(a[i++]));    for(uni i=0;i&lt;=m;read(b[i++]));    for(;lim&lt;=n+m;++l) lim&lt;&lt;=1;    for(uni i=1;i&lt;lim;++i)        r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l);    for(uni i=0;i&lt;lim;++i)        if(i&lt;r[i]){            swap(a[i],a[r[i]]);            swap(b[i],b[r[i]]);        }    for(uni mid=1,cnt=0;mid&lt;lim;mid&lt;&lt;=1,++cnt)        for(uni i=mid&lt;&lt;1,j=0;j&lt;lim;j+=i)            for(uni *x0=a+j,*y0=x0+mid,*x1=b+j,*y1=x1+mid,k=0,*g=pre.g+(1&lt;&lt;cnt);k&lt;mid;++k,++g,++x0,++y0,++x1,++y1){                uni t0=(ll)*g**y0%mod,t1=(ll)*g**y1%mod;                if((*y0=*x0-t0)&gt;M0) *y0+=mod;                if((*x0+=t0)&gt;M0) *x0-=mod;                if((*y1=*x1-t1)&gt;M0) *y1+=mod;                if((*x1+=t1)&gt;M0) *x1-=mod;            }    for(uni i=0;i&lt;=lim;++i)        a[i]=(ll)a[i]*b[i]%mod;    for(uni i=0;i&lt;lim;++i)        if(i&lt;r[i]) swap(a[i],a[r[i]]);    for(uni mid=1,cnt=0;mid&lt;lim;mid&lt;&lt;=1,++cnt)        for(uni i=mid&lt;&lt;1,j=0;j&lt;lim;j+=i)            for(uni *x=a+j,*y=x+mid,k=0,*g=pre.gi+(1&lt;&lt;cnt);k&lt;mid;++k,++g,++x,++y){                uni t=(ll)*g**y%mod;                if((*y=*x-t)&gt;M0) *y+=mod;                if((*x+=t)&gt;M0) *x-=mod;            }    for(uni i=0,inv=power(lim,mod-2);i&lt;=n+m;++i)         printf(\"%u \",(ll)a[i]*inv%mod);    return(0);}\r\n实测跑的很快。\r\n一些悬而未解的问题\r\n上面代码中有这样一句话：\r\nif((*y=*x-t)&gt;M0) *y+=mod;\r\nM0 被设为 0x7fffffff 也就是\r\nMaxInt，因为使用 unsigned 加速乘法所以这么写。因为当\r\nunsigned\r\n被设为负数时会向上溢出，这时我们再加一个模数即可溢出回来。\r\n但是还有这样一句话：\r\nif((*x+=t)&gt;M0) *x-=mod;\r\n显然这样就意味着在 int\r\n范围内自然溢出了，然后我们再把这个自然溢出的数减回来。\r\n这样看来似乎只要这个 M0\r\n能保证大于模数并保证加上一个模数在 unsigned\r\n范围内就能为一个合法的 M0，测试似乎确实如此。\r\n按照这个思路我们可以把 M0 设为  即可减少模数。\r\n但实际上在不同数据下，取模的次数并不为 M0 而减少。\r\n测试得 M0 似乎仍应为 。\r\n我对此暂时没有更多想法。\r\nFFT 的真正的优化\r\n上面所提到的优化已经可以切题了，但我们仍有方法做优化。\r\n毕竟谁会出裸的 FFT 啊，肯定要配合一些奇怪的东西跑的嘛\r\n以下内容可于 2016\r\n年国家集训队论文中的《再探快速傅里叶变换》中找到。\r\n所以看不懂请去找原作者\r\n设现在要求 \r\n（多项式的次数  已调整为 2\r\n的幂）。\r\n设\r\n\r\n设  为  的点值表示法的第  项，即为  .\r\n设 \r\n即共轭复数（IDFT 时出现过）。\r\n那么\r\n\r\n\r\n于是我们仅用一次 DFT 就可以算出  和  .\r\n算完考虑怎么得到  和\r\n ，于是有：\r\n\r\n\r\n于是我们把两次 DFT 变成了一次。\r\n因为PDF不能复制，上面这一大大大大段都是手打的，渲染得我 Typora\r\n都卡了\r\n又不是我写论文搞这么多干什么\r\n而且这玩意背板子就好了，理解毛线\r\n这个优化还有很多其他写法，不过在数学部分上是大部分相同的。\r\n在原论文中还有进一步优化为三次单倍长度 DFT 的方式，即“1.5 次\r\nDFT”，但是我太蒻了并不会。\r\nCODE\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#define N 262145#define uni unsigned#define reg register#define lf long double#define cp(a,b) (complex{a,b})using namespace std;const lf PI=acos(-1);uni n,m,lim=1,l=-1,r[N];char BuF[1&lt;&lt;26],*InF=BuF;struct complex{    lf r,i;    complex operator+(complex b){return(cp(r+b.r,i+b.i));}    complex operator-(complex b){return(cp(r-b.r,i-b.i));}    complex operator*(complex b){return(cp(r*b.r-i*b.i,r*b.i+i*b.r));}    complex operator/(uni b){return(cp(r/b,i/b));}    complex operator~(){return(cp(r,-i));}}a[N],ans[N],wn[N];template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}void dft(complex *a){    for(reg uni i=0;i&lt;lim;++i)        if(i&lt;r[i]) swap(a[i],a[r[i]]);    for(reg uni mid=1,cnt=l;mid&lt;lim;mid&lt;&lt;=1,--cnt)        for(reg uni i=mid&lt;&lt;1,j=0;j&lt;lim;j+=i)            for(reg uni k=0;k&lt;mid;++k){                complex x=a[j+k],y=wn[k&lt;&lt;cnt]*a[j+mid+k];                a[j+k]=x+y;                a[j+mid+k]=x-y;            }}int main(){    fread(BuF,1,1&lt;&lt;26,stdin);    read(n);read(m);    for(reg uni i=0;i&lt;=n;read(a[i++].r));    for(reg uni i=0;i&lt;=m;read(a[i++].i));    //这里直接在读入就把两个多项式合并    for(;lim&lt;=n+m;++l) lim&lt;&lt;=1;    for(reg uni i=1;i&lt;lim;++i)        r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l);    for(reg uni i=0,r=lim&gt;&gt;1;i&lt;r;++i)        wn[i]=cp(cos(i*PI/r),sin(i*PI/r));    dft(a);    a[lim]=a[0];    for(reg uni i=0;i&lt;lim;++i){        ans[i]=cp(0,-1)*(a[i]+~a[lim-i])*(a[i]-~a[lim-i])/4;        //直接计算乘积，当然也有在输出时处理的写法        //我们按照论文中的方式实现        wn[i]=~wn[i];    }    dft(ans);    for(reg uni i=0;i&lt;=n+m;++i)        printf(\"%u \",(uni)(ans[i].r/lim+0.5));    return(0);}\r\n这份代码实测跑的比 NTT 慢一点，但仍有意义（就在下面）。\r\nMTT\r\n一般认为是任意模数数论变换。\r\n不过已经广泛到还指拆系数 FFT 了。\r\n\r\n似乎实际上是“毛爷爷的 NTT”的意思？\r\n谷歌告诉我们展开是 Arbitrary Modulus Number Theory\r\nTransformation 即 AMNTT\r\n总之（至少名字）应该是个民间发明，因为维基上真的没有\r\n\r\nNTT 的局限在于模数有限制（某著名的 998244353 从 UOJ\r\n跑出来之后烂大街了，然后你发现就没有人用其他模数）， FFT\r\n的局限在于精度低，乘出来的数字一大就炸。\r\n于是就会有出题人放一些奇怪的模数恶心人，比如（杭电 ACM\r\n中出现过的）998244352 或 998344353 什么的。\r\n有两种思路：\r\n三模数 NTT\r\n思想比较简单，就是用 NTT\r\n能用的若干模数做三次，然后利用中国剩余定理两两合并。\r\n一般取三个，因为两个精度不够。（所以 99.9999% 的地方都叫三模数 NTT\r\n包括这里，虽然不一定是三个）\r\n也就是先求出结果在足够精度下的真值，然后取模。\r\n优化\r\n\r\n如果题目给的模数足够小只用两个就够了\r\n无\r\n\r\n所以学什么嘛，这么慢。\r\n以掩饰我懒所以不会\r\n拆系数 FFT\r\n考虑把 FFT 运算中的数变小以提高精度。\r\n考虑 \r\n，则我们可以把一个数  表示为  .\r\n然后考虑把原多项式用这种方法拆成两个多项式，一共四个多项式，然后乘出四个多项式，然后再合并起来。\r\n没了。\r\n实际情况就是根本不懂技术细节只会瞎胡。\r\n优化\r\n首先这玩意 8 次 DFT 已经吊打 NTT 9 次了好吧\r\n非常简单，用上面提到的方法将 4 次 DFT , 4 次 IDFT 两两合并，就只剩 4\r\n次 DFT 了。\r\n如果使用“1.5 次 DFT”可以做到“3.5 次\r\nDFT”，当然柿子过于复杂所以效果不明显。\r\n同时，一个重要的点就是对于每一个单位根，我们直接计算而不是取一次单位根的幂，这样可以保证精度。\r\n实测取一次单位根的幂会在 luogu 上 WA 两个点。\r\nCODE\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#define N 262145#define uni unsigned#define reg register#define lf long double#define ll uni long long#define cp(a,b) (complex{a,b})using namespace std;const lf PI=acos((lf)-1);uni n,m,mod,cmod,lim=1,l=-1,r[N];char BuF[1&lt;&lt;24],*InF=BuF;struct complex{    lf r,i;    complex operator+(complex b){return(cp(r+b.r,i+b.i));}    complex operator-(complex b){return(cp(r-b.r,i-b.i));}    complex operator*(complex b){return(cp(r*b.r-i*b.i,r*b.i+i*b.r));}    complex operator/(uni b){return(cp(r/b,i/b));}    complex operator~(){return(cp(r,-i));}}a[N],b[N],p[N],q[N],wn[N];template&lt;typename T&gt;void read(T &amp;x){    for(;47&gt;*InF||*InF&gt;58;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}void dft(complex *a){    for(reg uni i=0;i&lt;lim;++i)        if(i&lt;r[i]) swap(a[i],a[r[i]]);    for(reg uni mid=1,cnt=l;mid&lt;lim;mid&lt;&lt;=1,--cnt)        for(reg uni i=mid&lt;&lt;1,j=0;j&lt;lim;j+=i)            for(reg uni k=0;k&lt;mid;++k){                complex x=a[j+k],y=wn[k&lt;&lt;cnt]*a[j+mid+k];                a[j+k]=x+y;                a[j+mid+k]=x-y;            }}int main(){    fread(BuF,1,1&lt;&lt;24,stdin);    read(n);read(m);read(mod);    cmod=(uni)ceil(sqrt(mod));    for(reg uni i=0,x;i&lt;=n;++i){        read(x);x%=mod;        //不管你信不信取模真的有用        a[i]=(complex){(lf)(x/cmod),(lf)(x%cmod)};    }    for(reg uni i=0,x;i&lt;=m;++i){        read(x);x%=mod;        b[i]=cp((lf)(x/cmod),(lf)(x%cmod));    }    for(;lim&lt;=n+m;++l) lim&lt;&lt;=1;    for(reg uni i=1;i&lt;lim;++i)        r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l);    for(reg uni i=0,r=lim&gt;&gt;1;i&lt;r;++i)        wn[i]=cp(cos(i*PI/r),sin(i*PI/r));    dft(a);dft(b);    a[lim]=a[0];    for(reg uni i=0;i&lt;lim;++i){        p[i]=a[i]*b[i];q[i]=b[i]*~a[lim-i];    }    for(reg uni i=0;i&lt;lim;++i)        wn[i]=~wn[i];    dft(p);dft(q);    for(reg uni i=0;i&lt;=n+m;++i){        p[i].r/=lim;q[i].r/=lim;p[i].i/=lim;        reg ll ac=(p[i].r+q[i].r)/2+0.5,bd=q[i].r-ac+0.5,abcd=p[i].i+0.5;        printf(\"%llu \",((ac%mod*cmod%mod*cmod%mod)%mod+(abcd%mod*cmod%mod)%mod+bd%mod)%mod);    }    return(0);}\r\n总结\r\n好的，你现在已经切完了 luogu 、 uoj 、 loj 上的模板题了。\r\n现在快去切以下题目吧：\r\n\r\n「ZJOI2014」力\r\nFuzzy\r\nSearch\r\nKyoya and\r\nTrain\r\nTransforming\r\nSequence\r\n\r\n我太蒻了全都不会\r\n其实大部分时候 FFT/NTT/MTT\r\n都跟网络流算法类似，只要搞出一个卷积的模型跑板子就行了。\r\n所以你为什么会网络流1年多了才会卷积？\r\n","categories":["Note"],"tags":["Math","Poly"]},{"title":"速通字符串","url":"/post/Fast-Learn-String/","content":"\r\n本文的全名为：《论如何速通 T 学过的所有字符串科技》\r\n所以没学的这里就没有。\r\n\r\n定义 （及其变形）为字符串，下标从  开始。\r\n定义  为  的长度 \r\n定义  为  的  切片，。\r\n定义前缀  为 （或者简写为 ），后缀  为 （或者简写为 ）。\r\n定义 \r\n为两个串的最长公共前缀。\r\n代码瞎写的，甚至没编译，当伪代码看就好，当然如果挂了可以修。\r\nC/C++ 风格字符串操作\r\n见 cppreference。\r\n字符串哈希\r\nPKUSC 不会字符串哈希挂了 50pts，自闭了。\r\n考虑对于定义哈希为 ，然后显然如果  为质数的话则可差分，这样可以实现 \r\n的比较，并支持单点修改，并且还可以支持奇怪的东西比如表示两个字符串的差。\r\n注意到 \r\n应当远大于哈希数量的平方以保证正确率，一般来说可以取 ，我觉得这年头\r\n__int128\r\n都放开了就没必要写双模哈希了，因为取两次模怎么想都比取一次模慢不少。\r\nconst ll mo=4500000000000000011,base=50000017;struct num{    ll a;    num(const ll x=0){a=x;}    operator ll()const{return(a);}    num operator+(const num &amp;b)const{return(a+b&gt;=mo?a+b-mo:a+b);}    num operator-(const num &amp;b)const{return(a&gt;=b?a-b:a-b+mo);}    num operator*(const num &amp;b)const{return((i128)a*b%mo);}};\r\n\r\n一个经典科技是二分加上哈希判断某两个字符串的 ，然后判断下一位就能得到它们的大小关系。\r\nTrie\r\n大概是大部分人学的第一个 DFA？\r\n除了 ACAM 没甚么应用场合，感觉 01-Trie 用的比较多。\r\nstruct trie{    int size;    struct node{        int s[26];        bool leaf;    }a[N&lt;&lt;4];    char* add(char *s){        int now=0;        for(;32&lt;*s;now=a[now].s[*s++-97])            if(!a[now].s[*s-97])                a[a[now].s[*s-97]=++size]={};        a[now].leaf=1;        return(s);    }    bool find(char *s){        int now=0,re=0;        for(;32&lt;*s;)            if(!(now=a[now].s[*s++-97])) return(0);        return(a[now].leaf);    }};\r\nManacher\r\nManacher 比 KMP 简单所以先写 Manacher。\r\n考虑求 \r\n中的回文，显然对于一个回文 ，前后删除相同数量的字符仍然是回文。所以所有回文的信息可以用中心点加上最长长度表示。\r\n然后你发现对于一个字符串，将其反转得到的字符串里面的所有回文信息是不变的。\r\n所以对于一个回文 ，其左半部分和右半部分的回文信息是完全一样的（反转的）。\r\n那么，当我们求右半回文的时候，显然就可以直接复制左半部分的信息，注意不能超过大回文的最右端。\r\n取右端点最右的一个作为大回文即可。\r\n然后众所周知，回文的长度可以是偶数，所以我们在每两个字符中间随便塞个东西进去就可以全部转为奇数，最后连除二都不需要。\r\nfor(s[0]='@',s[1]='#';32&lt;*InF;++InF){    s[++n]=*InF;    s[++n]='#';}for(int i=1,mid=0,r=0;i&lt;n;++i){    if(i&lt;r) f[i]=min(f[(mid&lt;&lt;1)-i],r-i);    for(;s[i-f[i]-1]==s[i+f[i]+1];++f[i]);    if(i+f[i]&gt;r) r=i+f[mid=i];}\r\nKMP\r\n现在看来不如字符串哈希。\r\n首先定义 border 为字符串中相同的真前缀与真后缀的字符串。\r\n比如 bbabbabb 中 b,bb,bbabb 都是它的\r\nborder。\r\n然后定义  表示  的最长 border 长度。\r\n考虑求 ，对于 ，当  可以从  转移过来：\r\nabaa   abaa  pi[i-1]=4abaab   abaab pi[i]=5\r\n当然可能条件并不满足，但你发现由于 ，所以在\r\n 后面加一个字符可以等价为在\r\n\r\n后面加一个字符，所以你再试一下 \r\n能不能转移，然后你发现这个过程可以递归。\r\n正确证明的话，考虑这样做肯定能得到一个\r\nborder，然后对于最长只需向前归纳最后把锅丢给空串即可。\r\nfor(int i=1;i&lt;n;++p[i++])    for(int &amp;j=p[i]=p[i-1];~j&amp;&amp;s[j]!=s[i];j=j?p[j-1]:-1);\r\n这个实现看起来非常炫酷，注意到使用了三目运算符判断边界（即 border\r\n是空串）。\r\n其实更加建议写下面这种：\r\nfor(int i=1;i&lt;n;++i){    for(int &amp;j=p[i]=p[i-1];j&amp;&amp;s[j]!=s[i];j=p[j-1]);    p[i]+=s[p[i]]==s[i];}\r\n或者你也可以将字符串定义到  上，然后定义空串的 \r\n为 ，这样就无需显式地判断边界。\r\np[0]=-1;for(int i=2;i&lt;=n;++p[i++])    for(int &amp;j=p[i]=p[i-1];~j&amp;&amp;s[j]!=s[i];j=p[j]);\r\n\r\n然后考虑如何匹配，比如现在 \r\n已经匹配上了，如果 \r\n能继续匹配就继续匹配，如果不能匹配，那就选择  尝试匹配。\r\n正确性考虑反证，如果按照这样得到的第一个匹配前存在一个没有被找到的匹配，显然这需要现在保留下来的\r\n 更长，因为留下来的必然是\r\nborder，所以这是与 \r\n的定义矛盾的。\r\nfor(int i=0,j=0;i&lt;n;++i){    for(;j&amp;&amp;s[j]!=S[i];j=p[j-1]);    if((j+=s[j]==S[i])==n) printf(\"%d\\n\",i);}\r\nZ 函数\r\n（Aka 拓展 KMP）\r\n定义 ，否则  为 。\r\n考虑 Manacher 类似的过程，对于 ，其会覆盖  向后的  个字符，那么对于后面的第  个字符，就有 ，也就是  的一段后缀会等于  的一段后缀，然后  是求过的，所以直接搬过来即可。\r\nfor(int i=1,l=0,r=0;i&lt;n;++i){    if(i&lt;r) z[i]=min(z[i-l],r-i);    for(;s[i+z[i]]==s[z[i]];++z[i]);    if(i+z[i]&gt;r) r=i+z[l=i];}\r\n这个东西的能力跟前缀函数有不少重叠，并且被 SA\r\n完全包含，但是有时候可以让你不用写 SA，或者不用学习线性的 SA。\r\nAC 自动机\r\n（ACAM）\r\nKMP 是自动机，Trie 也是自动机，所以可以拼起来得到一个新的自动机。\r\n考虑对于若干模式串  对  进行匹配，我们将它们置入 Trie\r\n中，同时处理出 \r\n中所有后缀的包含关系，\r\n我们现在对目前匹配的 ，求出其最长的后缀满足  中存在一个  使得其前缀与该后缀相等，记录这个\r\n 的前缀在 Trie 中的位置。\r\n那么对于下一个字符，如果 Trie 能接受就直接接受，不然就像 KMP 一样跳\r\nborder 就行，在 Trie 上定义 border 就是寻找任意一个位置使其 Trie\r\n前缀等于当前后缀。\r\n那么求这个 Trie 的前缀函数与 KMP\r\n是一致的，对着父亲跳一下，没有继续跳，注意判断根的儿子不要连到自己了。\r\n考虑时间复杂度，你能往前跳的次数最多为你能往后跳的次数，而后者显然是\r\n。\r\n\r\n然后你细细思考发现这个定义与网上大部分的实现写的东西是不一样的。\r\n可以看看 ouuan\r\n的博客的评论，实际上网上的定义就是你考虑我们将这个转移（DFA\r\n上跳边称为转移）精细化一点，变成如果下一个字符是  的下一个结点。\r\n首先原先 Trie\r\n上的边是满足定义的我们不管它们，然后考虑对于不能接受的转移 ，那么是类似的，我们将它链接到所有\r\nborder 中最长的满足后继存在 \r\n转移的结点的 \r\n转移后的结点（或虚根）。\r\n说白了就是，原先的过程是跳 border 找 ，如果没找到继续跳 border，跳到有  的位置，然后向  转移。现在直接处理出这个  的位置在哪里一次跳过去。\r\n这样的好处是代码比较短（其实常数不一定变小，因为构建的常数变大了，所以需要\r\n\r\n非常非常长才有效果），缺点是空间比较大（如果是对于转移边动态开点的话，但是\r\nOI\r\n范围内想必大家都是开满的，不过对于汉字这样字符集巨大的就非常有用了）。\r\n实际上 KMP 也能这么处理，但是更劣了。\r\nstruct ACAM{    struct{        int s[26],fail,match;        bool leaf;    }a[M];    int size,d[M];    int add(char *s){        int now=0;        for(;*s&gt;32;){            int &amp;nxt=a[now].s[*s++-97];            now=nxt?nxt:nxt=++size;        }        a[now].leaf=1;        return(now);    }    void build(){        int h=0,t=-1;        for(int *i=a[0].s,*r=i+26;i&lt;r;++i)            if(*i) d[++t]=*i;        for(;h&lt;=t;++h)            for(int p=d[h],*i=a[p].s,*r=i+26,*f=a[a[p].fail].s;i&lt;r;++i,++f)                (*i?a[d[++t]=*i].fail:*i)=*f;    }    void match(char *s){        for(int now=0;*s&gt;32;++s)            ++t.a[now=t.a[now].s[*s-97]].match;    }    void finish(){        for(int t=size;t;--t)            a[a[d[t]].fail].match+=a[d[t]].match;    }}t;\r\n然后注意一下实现细节，首先我们使用队列因为要 BFS 整颗\r\nTrie，然后对于根的儿子直接先加入进队列，因为它们无需构建也不能构建（全连到根节点）。\r\n然后对于当前结点的 border 是保留了的，因为我们还需要跳 border\r\n这样一个操作，不过就不需要显式地循环来找到转移 \r\n了，可以理解为这是一个序列自动机的前缀结构。\r\n匹配需要注意因为字符串可以相互包含，非结尾的状态的前缀可能是结尾，所以若到了一个结点，则其所以\r\nborder 都被匹配了一次（尽管这些 border 可能不是一个  中的串），但是你并不能直接暴力跳 border\r\n来解决问题，因为这样时间复杂度会起飞。\r\n所以在匹配结束之后，我们倒序遍历整个 Trie 令每个结点将贡献打到 border\r\n串上。\r\n后缀数组\r\n（SA）\r\n重头戏。\r\n首先后缀数组 \r\n定义为将所有后缀排序（显然因为长度不等没有相同）之后排名为  的后缀的起始位置（即 ）。\r\n定义  为后缀\r\n 的排名。\r\n考虑一个简单的方法，对于每个后缀将其长度补全至 ，使用基数排序从后往前排序，这样的时间复杂度是\r\n。\r\n然后我们仔细想想这就等同于在前面每次插入一个数进去，那为什么不归并呢？\r\n所以我们从前往后倍增每次令每个后缀的长度都加倍，显然前后两部分都是排序好的，然后直接基数再排序一次即可。\r\n考虑具体的实现，如果直接基数排序需要排序两遍，这样太慢了。\r\n考虑这个过程是将第二部分排好序，然后将第一维放入桶中，然后按照第二部分倒序取出。\r\n我们发现将第二部分排好序已经做了，所以不管。将第一维放入，考虑第三步。你发现第二部分最小的那些，是倍增之后后半部分全为空串的，然后是按照我们之前排序的顺序，可以直接遍历。\r\n然后你发现每次倍增对于新生成的 \r\n都是直接覆盖的，所以我们可以开两个表示新的和旧的，每次用旧的生成新的，然后交换头指针即可。\r\n这份代码里的字符串是定义在  的，用于减少边界的判断。\r\n注意字符集应当从 \r\n开始定义，以便于同空字符区分。\r\nvoid SA(){    int *r0=_r[0],*r1=_r[1],*s0=_s[0],*s1=_s[1],m=27;    // 放入桶中    for(int i=1;i&lt;=n;++i) ++c[r1[i]=s[i]-96];    for(int i=1;i&lt;m;++i) c[i+1]+=c[i];    // 生成第一次的 sa 与 rk，如果两个后缀目前相同则具有相同的 rk    for(int i=n;i;--i) s1[c[r1[i]]--]=i;    for(int t=1;;t&lt;&lt;=1){        // 交换头指针，清空桶        swap(r0,r1);swap(s0,s1);        memset(c+1,0,m&lt;&lt;2);        // 放入桶中        for(int i=1;i&lt;=n;++i) ++c[r0[i]];        for(int i=1;i&lt;m;++i) c[i+1]+=c[i];        // 从大到小遍历，如果其前面有一个串倍增过来就处理它        // s0[i]-t 表示前面那个串        for(int i=n;i;--i)            if(s0[i]&gt;t) s1[c[r0[s0[i]-t]]--]=s0[i]-t;        // 这部分的倍增结果是空串，它们是最小的        // 由于它们的 rk 已经互不相同，所以它们的遍历顺序是无关紧要的        for(int i=n-t+1;i&lt;=n;++i) s1[c[r0[i]]--]=i;        // 生成 rk，对于目前相同的两个串生成相同的 rk        for(int i=m=r1[s1[1]]=1,*sf=r0+t;++i&lt;=n;)            r1[s1[i]]=m+=r0[s1[i]]!=r0[s1[i-1]]||sf[s1[i]]!=sf[s1[i-1]];        // 如果已经生成了 n 个互不相同的排名则直接退出        if(m==n) break;    }    sa=s1;rk=r1;}\r\n\r\n然后对于后缀数组有一个很重要的应用，求任意两个后缀的 。\r\n我们考虑对于排序后的数组，每个向前一个求 。\r\n也就是定义 。\r\n考虑如何快速求，因为两个原串相邻的后缀的差异较小的，可以考虑它们之间的情况。\r\n例如对于后缀 ，即为 ，而\r\n（以下设为 ）即为 ，将两个\r\n\r\n中的后缀写出来，它们是： \r\n假定我们已经知道后两者 （并且以下假定其大于\r\n），设其相等的部分等于 （ 某个字符），根据定义那么就有： \r\n根据 \r\n的定义，后缀 \r\n小于后缀 ，也即后缀\r\n\r\n小于后缀 ，并且因为它们的第一个字符相同，将其去掉并不影响大小关系，故有：\r\n 注意到 ，这样的话，后面就已经接近我们要求的\r\n\r\n对的一个了，考虑前面。\r\n而又再次根据 \r\n的定义，我们知道后缀 \r\n是小于后缀 \r\n最大的后缀（即它不可能小于 ，否则与 \r\n的定义矛盾），那么必然有：  于是我们得到  必然是\r\n\r\n的一个前缀，同时它也是 \r\n的一个前缀。\r\n那么我们得到结论：  （注意下标套的  不要忘了）\r\n根据这个结论我们可以写出代码：\r\nfor(int i=1,j=0;i&lt;=n;ht[rk[i++]]=j)    for(j-=j&amp;&amp;1;s[i+j]==s[sa[rk[i]-1]+j];++j);\r\n由于我们最多向前走 \r\n次，而向后走的步数为向前走的步数加 ，所以时间复杂度 。\r\n等一下，所以求任意两个后缀的  在哪里？\r\n我们考虑我们已经可以在排序好的数组上求相邻两个后缀的 ，那么两个不相邻的则是取中间的最小值，即：\r\n （注意前面套的 ，以及后面具体的大小关系看清楚）\r\n证明较为简单，考虑从前往后计算 ，如果变小了则说明此时存在字符\r\n 大于  的对应位置 ，若字符  重新等于 \r\n的对应位置，则说明其前面存在一个字符  大于  的对应位置。\r\n所以任何缩短必然使得最终的长度小于等于这个数，所以上限就是这个 ，至于下限用等于的传递性即可证明。\r\n回文自动机\r\n（PAM aka EER Tree, Palindromic Tree）\r\n回文自动机（或许应该叫回文树，但是我觉得 PAM\r\n比较符合串串科技的感觉）可以高效地储存字符串中的回文信息。\r\n首先我们要定义一个自动机，其结点储存  表示其表示的回文串长度、 表示儿子、 表示父亲。\r\n具有两个虚结点，一个为奇根（），另一个为偶根（），偶根的  指向奇根。\r\n然后定义除了根以外的结点的含义是，其表示的回文是其 \r\n指向的结点表示的回文、左右加上当前结点的字母的回文串，维护好 。\r\n然后就没有了，定义给出了其构建，因为有 ，每次判断当前结点的左边跟新加的字符是否一样，一样就跳儿子，若不存在则新建节点，不一样就跳\r\n。\r\n时间复杂度证明跟 KMP 一样。\r\n用途的话，比如说可以像 ACAM\r\n一样倒着遍历打标记，即可统计任意回文的出现次数。\r\nstruct PAM{    int size,len,last,in[N];    bool vis[N];    char *s;    struct node{        int cnt,s[26],len,fail,fa;    }a[N];    PAM(char *_s):s(_s){        a[1].len=-1;        size=a[0].fail=1;        fa[len=0]=1;        for(int n=strlen(s);len&lt;n;++len){            insert(s[len]);            in[len]=last;        }    }    int getfail(int x) {        for(;len-a[x].len&lt;0||s[len-a[x].len-1]!=s[len];x=a[x].fail);        return(x);    }    void insert(char x){        int now=getfail(last),c=x-97;        if(!a[now].s[c]){            a[++size].len=a[now].len+2;            a[size].fail=a[getfail(a[now].fail)].s[c];            fa[size]=a[size].fail;            a[a[now].s[c]=size].fa=now;        }        ++a[last=a[now].s[c]].cnt;    }};\r\n","categories":["Note"],"tags":["String"]},{"title":"GDKOI 2023","url":"/post/GDKOI-2023/","content":"一开始准备的是，只要见到最优化，就先打个暴力和随机化先，反正不要几分钟。\r\n好吧没有最优化。\r\nD0\r\n坐车坐了三个小时，不是很懂去海珠区的六中为什么要跑到天河区去。\r\n用新设备入坑了\r\nARC，但是读谱大失败加上严重晕车加上困所以没怎么打。\r\n因为连续登录微信导致冻结，结果身份信息不是我的，草生。\r\n\r\n餐厅中规中矩吧。\r\nD1\r\n早上起来发现餐票丢进洗衣机了。\r\n打电话回家试图解冻微信，用现金吃了早餐，付完试了试发现解冻了。\r\n去到六中成功没找到考场，一堆红色的路障愣是一个没看到。\r\n\r\n进考场拉凳子的时候发现屏幕重启了，黑人问号。\r\n发现没贴考号，溜出去背了一下。\r\n后面一堆人发现没贴考号，全出去了。\r\n\r\nT1 是模  版本中山市选\r\n2008 原题，原题 ，当时我坐在讲题的机房，莫名其妙记了好几年，没甚么好说的直接秒了。\r\nT2 是模  计数题。\r\nT3 是模  计数题。\r\n#查询出题人精神状态#\r\n碰到了电线，然后黑屏了，确认了一下没关机，然后继续想题，看看会不会重启。\r\n结果一直没重启，发现是电源插头插松了（不懂当时是什么精神状态去检查了机柜后面的接口）。\r\n花了 1h 码完 T1 和对拍，然后开\r\nT2，先拿容斥推了错排，然后推了个不知道什么柿子。\r\n啊对的对的，啊不对不对，啊是对的，啊是错的。\r\n总之是错的。\r\n然后看了会\r\nT3，跟某道模拟赛题有一个限制是一样的，但是另一个限制鬼一样难做。\r\n回到 T2，推了一会 \r\nDP，胡乱写了半天。看到样例没过准备调试，发现小数据输出是对的，然后发现样例是对的。\r\n#查询精神状态#\r\n然后把 T3\r\n的暴力码了，又码了状压（实际上过不去，没算复杂度的屑）。\r\n回来看了看 T2 感觉好像 \r\n过不去卡了卡常，DP 式子结构很差，盯着看了半天不知道怎么优化。\r\n随便搞搞，继续拍 T1，然后就结束了。\r\n\r\n出来发现 \r\n是大众分，沮丧。\r\nT2 用容斥可以轻松优化到 \r\n多拿  分，但是我是正向创的 ，沮丧。\r\n发现中午没甚么时间睡觉。\r\n\r\n讲题时间很短，后面讲座全溜了，我跟 lxl 和 dsn\r\n留在那不知道干啥（大概在等分数？）。\r\nT3 的 \r\n分的包是留给被卡常的正解，但是放在第二个包十分迷惑，吓的我一度以为是不是有什么简单的搞复杂度做法。\r\n结果到时间了那边说好多人代码跑得很慢卡评测机，还有什么每次运行分数不一样的要人工复核，要等吃完饭才有分，草生。当场跟\r\ndsn 溜了。\r\n晚上肉鸽，肉鸽好香。\r\nD2\r\n早上到了六中门口发现比昨天早了半个小时门还没开，赶紧通了一把胡局。\r\n\r\nT1 一眼蠢题，三个点找\r\nLCA，然后解个方程就变成维护三条链然后三维偏序，然后再整个倍增就行了（后半部分可以线性，但是懒），花两个小时写了\r\n6k 和对拍，没有大样例是真的蠢。\r\n感觉 T1 \r\n的复杂度不是很对跑了跑发现瓶颈在输入，于是写了快输。\r\nT2 是个期望题，看半天感觉不对，发现一直在假，后面发现每一次加一个\r\n，写最后算了算确定自己拿不到暴力分就润了。\r\nT3\r\n先码了个暴力，然后有一点点的部分分的想法，但是好像又没甚么想法。\r\n最后在 T2 和 T3 之间做了一个小时的牢，未果，寻病终。\r\n\r\n出来发现 T1 的三维偏序有一维是没用的所以可以 ，蠢了，不过无所谓反正卡了常。\r\n下午滚榜时说 T2 最高分 ，阿巴\r\nFWT 白学了。\r\n感觉自己 \r\n没甚么希望，排名感觉大概就一半少点。\r\n发现两天的 T1 都被假做法穿了，据说 D1T1\r\n有随几百个点就创过去的（好像什么每次都不一样的就是这题了，好像处理方式是取最大值，那这题就变成是否被注意到，注意到估计都满了，乐），D2T1\r\n有找一条直径就创过去的，绷。\r\n问了下好像 D2T1 有相当比例没调出来的。\r\n最后两天 T3 暴力全挂了变成 ，刚好卡在一等线外，绷。\r\n想起来上次联合省选 2019 好像也是两天 T3\r\n没分，要是有暴力分的话可以水到一等的。\r\n草，历史重演了属于是。\r\n懂了，下一把 GDOI 两天的 T3 只要有分就算胜利。\r\n\r\n不太懂出题人两天出了三道计数，两道数据结构，一道签到是什么心态，大概是备战\r\nCTS 罢。\r\n行吧没有大样例的话下次把暴力一块拿去拍算了。\r\n","categories":["Record"],"tags":["Log"]},{"title":"GDOI 2023","url":"/post/GDOI-2023/","content":"两年过去了，菜还是菜。\r\nD1\r\nT1 是水题秒了，没甚么可说的，硬要说就是用了  的 sort 比较蠢。\r\nT2\r\n显然可以发现点双联通分量要么不拆要么全拆，转化成一棵树拿一个连通块出来每个点挂一个\r\n 的子树，然后就不大会做了，写的\r\n，猜结论连通块一定过重心，然后把整除判掉，再写个暴力就有\r\n。\r\n写的时候感觉细节很恶心。\r\nT3 一眼可并堆有 \r\n先写了，后面有了点思路但是被自己否了。\r\nLHF 说 T2 就用这些就能切了，我感觉也是，但是细节根本想不明白。\r\nD2\r\nT1 写假做法写了 3h，最后写了一个 BFS\r\n的做法有些接近了，但是自己否了，最后调试完全不知道在调什么。\r\nT2 读题大失败，没看到 ，想了半个小时确定不弱于二分图匹配，非常迷惑因为网络流做这个判断有无解匹配就要\r\n 了，\r\n然后判断有无解一开始想了个费用流模型发现假了，如果是 Bob\r\n先手就是真的。最后只能套一个指数级暴力上去水 。\r\nT3\r\n题意非常长而且神秘，最后根本就没有时间想了，看了一眼数据范围发现没给多少暴力分，而且感觉求权值的子问题都只会指数暴力，这样暴力分都拿不到。\r\n被 T1 带崩了整场，后面发现 T1 写的 \r\n的特判还假了。不过问了下，感觉后面能拿的可能加起来也没有 。\r\n被搜索区分了，垃圾。\r\n除了 D1T3 全挂了，垃圾。\r\n不挂分不如两年前，垃圾。\r\n","categories":["Record"],"tags":["Log"]},{"title":"HDU2022 D1T4 Ball","url":"/post/HDU2022-1-D/","content":"暴力出奇迹。\r\n\r\n题意\r\n平面上 \r\n个点，问取三个点的方案数使得三个点的三个曼哈顿距离排序后第二个为素数。\r\n\r\n思路\r\n据说这道题可以转成切比雪夫距离然后有很优雅的 \r\n做法，但是我不会。\r\n我们考虑 \r\n怎么做，由于“素数”是个极度奇怪的限制，所以我们不妨枚举这条中间的边的长度为\r\n，然后就可以得到两个点。接下来只需要在一个端点的边中选一条长度小于等于\r\n\r\n的边，另一个选取一条长度大于等于 \r\n的边，只要这两条边具有相同的顶点就可以构成一个合法方案了。\r\n这样只要每个点的边是按照长度排序的，就可以变成两个范围内的一些数据取并的问题的了。\r\n由于取并是一个难以维护的操作，我们直接选择 Bitset。\r\n由于 \r\n的空间是无法接受的，所以我们不能对于排序之后的边的前后缀维护\r\nBitset，只能选择通过对全局边进行排序，然后按照顺序枚举以将对 Bitset\r\n的维护转换成类似于指针扫描的形式。\r\n需要注意的是，对于三条边中有两条边或三条边相等的情况，我们会算重，所以需要对于等于\r\n 的边单独开一个 Bitset\r\n将这些情况处理出来，再进行修正。\r\n实现\r\n细节不少。\r\n我们注意到在计算等于 \r\n的边的时候我们可能直接计算到我们枚举的这条边，所以我们再用一个 Bitset\r\n将两个端点去掉。\r\n首先，如果我们直接的将小于等于大于三种 Bitset\r\n按照如上的方式操作计算答案，是无法通过此题的，因为计算有两条边相等的代码看起来像这样：\r\n(((pre[i.x]&amp;mid[i.y])|(mid[i.x]&amp;suf[i.y])|(pre[i.y]&amp;mid[i.x])|(mid[i.y]&amp;suf[i.x]))&amp;none).count()\r\n这将带来一个巨大的常数。\r\n所以对于有两条边相等的情况我们需要特殊处理。\r\n我们可以枚举一个点，然后扫描其每一组相同长度的边，然后进行统计。\r\n因为有两条边的长度一样，所以这个长度一定会是中间的那条边的长度。\r\n问题在于我们会将三条边相同的情况计算三次，所以我们需要按照上面的方法将三边相同的情况计算出来，然后容斥掉。\r\n另外，真正的优化（好像可以只使用这个优化就能过）是我们对于全局边排序时使用计数排序（因为值域只有\r\n），然后按照这个顺序加边，这样就可以避免多余的排序，在极限数据上可以直接优化掉一秒多。\r\nCODE\r\n#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;deque&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=2010,FSIZE=1&lt;&lt;24,MX=200010;using uni=unsigned;using ll=long long;using db=double;int x[N],y[N],w[MX],pr[MX/10];bool no[MX];struct line{int d,x;};struct line2{int d,x,y;};bitset&lt;N&gt; pre[N],mid[N],suf[N],none;deque&lt;line&gt; a[N];deque&lt;line&gt;::iterator l[N],r[N];vector&lt;line2&gt; all;line2 tmp[N*N];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    bool f=1;    for(;48&gt;*InF||*InF&gt;57;f^=*InF++=='-');    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));    x=f?x:-x;}int dis(int i,int j){    return(abs(x[i]-x[j])+abs(y[i]-y[j]));}void get(int x,int d){    for(;r[x]!=a[x].end()&amp;&amp;r[x]-&gt;d&lt;=d;++r[x]){        mid[x][r[x]-&gt;x]=1;        suf[x][r[x]-&gt;x]=0;    }    for(;l[x]!=a[x].end()&amp;&amp;l[x]-&gt;d&lt;d;++l[x]){        pre[x][l[x]-&gt;x]=1;        mid[x][l[x]-&gt;x]=0;    }}template&lt;class T&gt;void Sort(T beg,T end){    memset(w,0,sizeof(w));    for(auto i=beg;i&lt;end;++w[i++-&gt;d]);    for(int *i=w,*r=w+MX;i&lt;r;++i) *(i+1)+=*i;    for(auto i=beg;i&lt;end;++i) tmp[--w[i-&gt;d]]=*i;    memcpy(&amp;*beg,tmp,(end-beg)*sizeof(line2));}void work(){    int n,m;    ll ans1=0,ans3=0;    read(n);read(m);    all.clear();    for(int i=1;i&lt;=n;++i){        read(x[i]);read(y[i]);        a[i].clear();    }    for(int i=1;i&lt;n;++i)        for(int j=i+1;j&lt;=n;++j)            all.push_back({dis(i,j),i,j});    Sort(all.begin(),all.end());    for(auto i:all){        a[i.x].push_back({i.d,i.y});        a[i.y].push_back({i.d,i.x});    }    for(int i=1;i&lt;=n;++i){        pre[i].reset();        mid[i].reset();        suf[i].reset();        l[i]=r[i]=a[i].begin();        for(auto j:a[i]) suf[i][j.x]=1;    }    none.set();    for(auto i:all)        if(!no[i.d]){            get(i.x,i.d);            get(i.y,i.d);            none[i.x]=none[i.y]=0;            ans1+=(((pre[i.x]&amp;suf[i.y])|(pre[i.y]&amp;suf[i.x]))&amp;none).count();            ans3+=(mid[i.x]&amp;mid[i.y]&amp;none).count();            none[i.x]=none[i.y]=1;        }    for(int i=1;i&lt;=n;++i){        auto j=a[i].begin(),k=j;        for(;j!=a[i].end();j=k){            for(k=j;j-&gt;d==k-&gt;d&amp;&amp;k&lt;a[i].end();++k);            if(!no[j-&gt;d]) ans1+=(k-j)*(k-j-1)&gt;&gt;1;            if(k==a[i].end()) break;        }    }    printf(\"%lld\\n\",ans1-(ans3/3)*2);}int main(){    fread(BuF,1,FSIZE,stdin);    int t;    no[1]=1;    for(int i=2,cnt=0;i&lt;MX;++i){        if(!no[i]) pr[cnt++]=i;        for(int j=0;j&lt;cnt&amp;&amp;i*pr[j]&lt;MX;++j){            no[i*pr[j]]=1;            if(!(i%pr[j])) break;        }    }    for(read(t);t--;work());    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Bitset","Bruce Force"]},{"title":"HDU2022 D1T7 Treasure","url":"/post/HDU2022-1-G/","content":"倒数第 16 AC。\r\n\r\n题意\r\n给  个点  条边的无向图，点  有种类  与权值 ，边有边权有两种操作：\r\n\r\n将某个点的权值增加。\r\n询问从  出发走边权小于 \r\n的边形成的连通块中，每种种类的最大权值的和是多少。\r\n\r\n\r\n每种种类不超过十个点。\r\n思路\r\n因为有走过的最大边不能超过一个数这样的条件，我们马上就可以想到\r\nKruskal 重构树。\r\n这样我们的连通块就变成了重构树上的一颗子树了。\r\n我们思考“每种种类不超过十个点”这个诡异限制有什么用，首先可以猜测这个\r\n 是直接乘进最终复杂度里的。\r\n然后我们思考两个同种类的点 \r\n之间会有什么互动，比如设 \r\n的权值较小。那么从 \r\n向上走时，这一段的这个种类的最大点为 ，直到我们走到的这个点的子树中包含了\r\n 为止。然后再向上走最大点就变成了\r\n，直到包含一个比  权值更大的同类点。\r\n而显然的，如果我们走了一段最大值为  的权值的点，那么从  到这一段点的最大点一定全为 。\r\n那么我们不妨设每个（原图中的）点有一个“控制范围”，表示从这个点向上走直到一个点包含了比这个点权值更大的相同种类的点。\r\n在一个点的控制范围内，这个种类的最大值为这个点的权值。\r\n显然的，如果我们正确地维护了每个点的控制区间，那么查询只需要向上倍增到最上的一个点，然后将这个点属于的所有控制区间所代表的权值加起来就可以得到答案了。\r\n接下来我们考虑修改操作，权值只增不减，这是个很好的性质，这意味着只有可能是这个被增加的点获得更大的控制区间，而不可能是将控制区间让给某个点。\r\n\r\n似乎减小也是可以做的，但是这样就要分讨，而且不好写，会把题出的很不优雅。\r\n但是出题人整多组数据要各种清空其实就挺不优雅的。\r\n勉强当 ACM 特性看待。\r\n\r\n所以我们可以从这个点一路向上，对于新获得的控制区间，我们将新的权值与原权值做差就可以变成一个只加的操作。于是对一个维护出子树的答案就十分简单了。\r\n接下来考虑优化复杂度，我们发现从一个点向上（对于同一个种类的点）最多只有十个不同的控制区间（同一种类的点的\r\nLCA 最多只有十个，而这些 LCA\r\n之间的控制区间是不会改变的）。所以我们在向上拓展时，可以对于最近的同种类的点来进行判断，跳到相应的\r\nLCA 然后进行树上路径修改。\r\n由于我比较无脑，树上路径修改写了树剖。\r\nCODE\r\n调试惊险又刺激，在距离结束还有 1min46s 时获得了 AC。\r\n不是很懂都 2022 年了怎么还有 OJ 没有开全栈的，导致我没敢写 DFS。\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=400010,ON=200010,FSIZE=1&lt;&lt;26;using uni=unsigned;using ll=long long;using db=double;using iter=vector&lt;int&gt;::iterator;int n,m,q;int s[N],c[N],in[N],st[N],sze,cnt;int lcas[ON][10][10],pl[N];int mx[N],up[N][21];int dfn[N],dfsn,hs[N],sz[N],tp[N];ll p[N];bool geths[N];struct edge{int u,v,l;}e[N];vector&lt;int&gt; t[N];vector&lt;int&gt; col[N];struct ST{    ll a[N&lt;&lt;2];    void clear(){memset(a,0,sizeof(a));}    void add(int x,int y,int z,int m=1,int l=1,int r=dfsn){        if(x&lt;=l&amp;&amp;r&lt;=y){            a[m]+=z;            return;        }        int mid=(l+r)&gt;&gt;1;        if(x&lt;=mid) add(x,y,z,m&lt;&lt;1,l,mid);        if(mid&lt;y) add(x,y,z,m&lt;&lt;1|1,mid+1,r);    }    ll operator[](int x){        ll re=a[1];        int m=1,l=1,r=dfsn,mid;        for(;l&lt;r;re+=a[m])            if(x&lt;=(mid=(l+r)&gt;&gt;1)){                m&lt;&lt;=1;                r=mid;            }else{                m=m&lt;&lt;1|1;                l=mid+1;            }        return(re);    }}St;char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}int root(int x){return(s[x]?s[x]=root(s[x]):x);}int kruskal(int n,int m){    sort(e+1,e+m+1,[](edge a,edge b){return(a.l&lt;b.l);});    cnt=n;    for(int i=1,x,y;i&lt;=m;++i){        if((x=root(e[i].u))!=(y=root(e[i].v))){            p[s[x]=s[y]=++cnt]=e[i].l;            t[cnt].push_back(x);            t[cnt].push_back(y);        }    }    return(cnt);}iter tpi[N];void dfs0(int sp){    for(int i=1;i&lt;=cnt;++i) tpi[i]=(iter)nullptr;    for(st[sze=1]=sp;sze;){        int x=st[sze];        auto &amp;i=tpi[x];        if(i==(iter)nullptr){            sz[x]=1;            for(int &amp;i=mx[x]=1;up[up[x][i-1]][i-1];++i)                up[x][i]=up[up[x][i-1]][i-1];            i=t[x].begin();            if(c[x]){                auto &amp;tmp=col[c[x]];                pl[x]=tmp.size();                for(auto j=tmp.begin();j!=tmp.end();++j){                    lcas[c[x]][pl[x]][j-tmp.begin()]=                    lcas[c[x]][j-tmp.begin()][pl[x]]=root(*j);                }                tmp.push_back(x);            }        }else{            sz[x]+=sz[*i];            if(sz[*i]&gt;sz[hs[x]]) hs[x]=*i;            ++i;        }        if(i!=t[x].end()) up[st[++sze]=*i][0]=x;        else{            s[x]=up[x][0];            --sze;        }    }}void dfs1(int sp){    for(int i=1;i&lt;=cnt;++i) tpi[i]=(iter)nullptr;    tp[sp]=sp;    for(st[sze=1]=sp;sze;){        int x=st[sze];        if(!geths[x]){            dfn[x]=++dfsn;            geths[x]=1;            if(hs[x]) tp[st[++sze]=hs[x]]=tp[x];            continue;        }        auto &amp;i=tpi[x];        if(i==(iter)nullptr) i=t[x].begin();        else ++i;        for(;i!=t[x].end()&amp;&amp;*i==hs[x];++i);        if(i!=t[x].end()) tp[st[++sze]=*i]=*i;        else --sze;    }}ll get(int x,int y){    for(int i=mx[x];~i;--i)        if(p[up[x][i]]&lt;=y&amp;&amp;up[x][i]) x=up[x][i];    return(St[dfn[x]]);}void modify(int t,int x,ll add){    for(;tp[t]!=tp[x];x=up[tp[x]][0])        St.add(dfn[tp[x]],dfn[x],add);    if(t!=x) St.add(dfn[t]+1,dfn[x],add);}void add(int x,int y){    p[x]+=y;    if(col[c[x]].size()&lt;2){        modify(0,x,y);        return;    }    ll lmo=y;    for(int np=pl[x],l=np,r=np,lp=x;1;){        int lc=l?lcas[c[x]][l-1][np]:0,            rc=r+1&lt;(int)col[c[x]].size()?lcas[c[x]][np][r+1]:0;        if(!lc&amp;&amp;!rc){            modify(0,lp,lmo);            return;        }        if(dfn[lc]&gt;dfn[rc]){            modify(lc,lp,lmo);            int lst=p[col[c[x]][l-1]];            if(lst&lt;p[x]){                lp=lc;                lmo=min(p[x]-lst,lmo);            }else return;            --l;        }else{            modify(rc,lp,lmo);            int lst=p[col[c[x]][r+1]];            if(lst&lt;p[x]){                lp=rc;                lmo=min(p[x]-lst,lmo);            }else return;            ++r;        }    }}void work(){    memset(s,0,sizeof(s));    memset(p,0,sizeof(p));    memset(c,0,sizeof(c));    memset(up,0,sizeof(up));    memset(hs,0,sizeof(hs));    memset(lcas,0,sizeof(lcas));    memset(geths,0,sizeof(geths));    St.clear();    read(n);read(m);read(q);    for(int i=1;i&lt;=n+n;++i){        t[i].clear();        col[i].clear();    }    for(int i=1;i&lt;=n;++i) read(c[i]);    for(int i=1;i&lt;=n;++i) read(in[i]);    for(int i=1;i&lt;=m;++i){        read(e[i].u);read(e[i].v);read(e[i].l);    }    kruskal(n,m);    memset(s,0,sizeof(s));    dfsn=0;    dfs0(cnt);    dfs1(cnt);    for(int i=1;i&lt;=n;++i) add(i,in[i]);    for(int i=1,t,x,y;i&lt;=q;++i){        read(t);read(x);read(y);        if(t) printf(\"%lld\\n\",get(x,y));        else add(x,y);    }}int main(){    fread(BuF,1,FSIZE,stdin);    int t=0;    for(read(t);t--;work());    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Data Structure","Tree","Graph"]},{"title":"HDU2022 D5T4 Surveying","url":"/post/HDU2022-5-D/","content":"典中典式出锅。\r\n\r\n题意\r\n给  个矩形与 \r\n个特殊点，两个点之间能看到为两点之间线段除去两点严格不交于所有矩形的边。\r\n求使得每个（选取的，存疑，出题人不会写题面）特殊点与每个矩形的顶点被选取的特殊点看到的最小选取数。\r\n\r\n思路\r\n预处理两两之间情况，然后直接枚举选取情况并状压 DP 即可。\r\nCODE\r\n似乎因为快读没有负数寄了。\r\n#include&lt;bitset&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;using uni=unsigned;using ll=long long;using db=double;const int N=21,M=410,FSIZE=1&lt;&lt;24,INF=0x7f7f7f7f;int n,m;bitset&lt;M&gt; t[(1&lt;&lt;21)-1];bitset&lt;N&gt; b[(1&lt;&lt;21)-1];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    bool f=1;    for(;48&gt;*InF||*InF&gt;57;f^=*InF++=='-');    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));    x=f?x:-x;}struct point{    db x,y;    bool operator==(point b){return(x==b.x&amp;&amp;y==b.y);}    bool operator!=(point b){return(x!=b.x||y!=b.y);}    db operator*(point b){return(x*b.x+y*b.y);}};struct line{    point a,b;    point operator&amp;(line y){        db t=((a.x-y.a.x)*(y.a.y-y.b.y)-(a.y-y.a.y)*(y.a.x-y.b.x))            /((a.x-b.x)*(y.a.y-y.b.y)-(a.y-b.y)*(y.a.x-y.b.x));        return((point){a.x+(b.x-a.x)*t,a.y+(b.y-a.y)*t});    }};point a[N],p[N&lt;&lt;2];bool check(point x,int l,int r,point t){    if(t==p[l]||t==p[r]) return(0);    auto q=(line){p[l],p[r]}&amp;(line){x,t};    return(        min(p[l].x,p[r].x)&lt;=q.x&amp;&amp;q.x&lt;=max(p[l].x,p[r].x)&amp;&amp;        min(p[l].y,p[r].y)&lt;=q.y&amp;&amp;q.y&lt;=max(p[l].y,p[r].y)&amp;&amp;        min(x.x,t.x)&lt;=q.x&amp;&amp;q.x&lt;=max(x.x,t.x)&amp;&amp;        min(x.y,t.y)&lt;=q.y&amp;&amp;q.y&lt;=max(x.y,t.y));}bool can(point x,point y){    for(int i=0;i&lt;m&lt;&lt;2;i+=4){        if(check(x,i,i+1,y)) return(0);        if(check(x,i+1,i+2,y)) return(0);        if(check(x,i+2,i+3,y)) return(0);        if(check(x,i+3,i,y)) return(0);    }    if(x.x==y.x)        for(int i=0;i&lt;m&lt;&lt;2;++i)            if(p[i]!=y&amp;&amp;p[i].x==x.x&amp;&amp;min(x.y,y.y)&lt;=p[i].y&amp;&amp;p[i].y&lt;=max(x.y,y.y)) return(0);    if(x.y==y.y)        for(int i=0;i&lt;m&lt;&lt;2;++i)            if(p[i]!=y&amp;&amp;p[i].y==x.y&amp;&amp;min(x.x,y.x)&lt;=p[i].x&amp;&amp;p[i].x&lt;=max(x.x,y.x)) return(0);    return(1);}void work(){    read(n);read(m);    for(int i=1;i&lt;=n;++i){        t[1&lt;&lt;(i-1)].reset();        b[1&lt;&lt;(i-1)].reset();        read(a[i].x);read(a[i].y);    }    for(int i=0;i&lt;m;++i){        read(p[i&lt;&lt;2].x);read(p[i&lt;&lt;2].y);        read(p[(i&lt;&lt;2)+1].x);read(p[(i&lt;&lt;2)+1].y);        read(p[(i&lt;&lt;2)+2].x);read(p[(i&lt;&lt;2)+2].y);        read(p[(i&lt;&lt;2)+3].x);read(p[(i&lt;&lt;2)+3].y);    }    for(int i=1;i&lt;=n;++i)        for(int j=0;j&lt;m&lt;&lt;2;++j)            t[1&lt;&lt;(i-1)][j]=can(a[i],p[j]);    for(int i=1;i&lt;=n;++i)        for(int j=1;j&lt;=n;++j)            if(i!=j) b[1&lt;&lt;(i-1)][j]=can(a[i],a[j]);    int ans=0x7fffffff;    for(int i=1;i&lt;1&lt;&lt;n;++i)        if(__builtin_popcount(i)&lt;ans){            b[i]=b[i&amp;(i-1)]|b[i&amp;-i];            if((t[i]=t[i&amp;(i-1)]|t[i&amp;-i]).count()==m&lt;&lt;2){                bool all=1;                for(int j=i;j;j&amp;=j-1)                    if(!b[i][__builtin_ffs(j)]){                        all=0;                        break;                    }                if(all&amp;&amp;__builtin_popcount(i)&gt;1) ans=__builtin_popcount(i);            }        }    if(ans==0x7fffffff)        printf(\"No Solution!\\n\");    else        printf(\"%d\\n\",ans);}int main(){    fread(BuF,1,FSIZE,stdin);    int t;    for(read(t);t--;work());    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Geometry","Bruce Force"]},{"title":"HDU2022 D4T5 Link with Level Editor II","url":"/post/HDU2022-4-E/","content":"不晓得题解什么技巧。\r\n\r\n题意\r\n给  张图，每张图有 \r\n个结点与若干条普通边（有向）的图，图与图之间相同编号的结点之间有一条从编号较小到编号较大的特殊边，定义一条路径为从编号最小的图的点\r\n 出发到达编号最大的图的点 \r\n且不能连续经过两条普通边（允许连续经过特殊边），问 \r\n张图的一个最大的连续子段使得其不同路径数目小于 。\r\n\r\n思路\r\n首先对于  的 DP\r\n还是比较好想的，我们直接枚举这个子段，然后设  表示从这个子段的开始走到末尾的点\r\n 的路径数。\r\n然后考虑进行优化，由于题目中说了只需要路径数小于等于 \r\n而不一定要走到，所以我们的子段越长一定是越难合法的。\r\n那么我们考虑进行双指针，但是一般的双指针尺取需要删除操作，显然我们不能支持删除。\r\n那么 \r\n是不太可能了，我们发现  很小而\r\n 很大，可以考虑使用  的复杂度来换  的复杂度。\r\n由于一维的距离是难以进行操作（只支持在后端加边），所以我们使用邻接矩阵来表示这个数组。\r\n这样在两个方向上的加点（话说，我们好像是加一整张图来着）就可以做到了，由于图非常的稀疏，通过先枚举较为稀疏的矩阵可以将加入单点的操作的时间复杂度降为\r\n。\r\n但是还是不能删除。\r\n那么我们掏出无删尺取（Baka's\r\nTrick），并且发现我们合并的时间复杂度实际上是 。\r\n\r\n因为我们合并操作其实只关心 ，而只得到这个值的复杂度是很小的。\r\n\r\n那么最后的时间复杂度就是 。\r\nCODE\r\n题解提到了“对顶栈的技巧”不晓得具体指什么。\r\n#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using ll=long long;using namespace std;const int N=5010,FSIZE=1&lt;&lt;26;int n,m,k;struct graph{    ll a[21][21];    graph(){memset(a,0,sizeof(a));}    void clear(){memset(a,0,sizeof(a));}    ll operator()()const{return(a[1][m]);}}g[N],f[N];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    bool f=1;    for(;48&gt;*InF||*InF&gt;57;f^=*InF++=='-');    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));    x=f?x:-x;}graph pushL(const graph &amp;a,const graph &amp;b){    graph re=a;    for(int i=1;i&lt;=m;++i)        for(int j=1;j&lt;=m;++j)            re.a[i][j]+=b.a[i][j];    for(int k=1;k&lt;=m;++k)        for(int i=1;i&lt;=m;++i)            if(a.a[i][k])                for(int j=1;j&lt;=m;++j)                    re.a[i][j]+=a.a[i][k]*b.a[k][j];    return(re);}graph pushR(const graph &amp;a,const graph &amp;b){    graph re=a;    for(int i=1;i&lt;=m;++i)        for(int j=1;j&lt;=m;++j)            re.a[i][j]+=b.a[i][j];    for(int k=1;k&lt;=m;++k)        for(int j=1;j&lt;=m;++j)            if(b.a[k][j])                for(int i=1;i&lt;=m;++i)                    re.a[i][j]+=a.a[i][k]*b.a[k][j];    return(re);}ll merge(const graph &amp;a,const graph &amp;b){    ll re=a()+b();    for(int i=1;i&lt;=m;++i)        re+=a.a[1][i]*b.a[i][m];    return(re);}void work(){    int ans=0;    read(n);read(m);read(k);    for(int i=1,l;i&lt;=n;++i){        read(l);        g[i].clear();        for(int j=1,x,y;j&lt;=l;++j){            read(x);read(y);            g[i].a[x][y]=1;        }    }    f[1]=g[1];    for(int l=1,mid=1,r=1;1;f[r]=g[r]){        for(;l&gt;1&amp;&amp;(f[l-1]=pushL(g[l-1],f[l]))()&lt;=k;--l);        for(;l&lt;=mid;++l){            for(;r&lt;n&amp;&amp;merge(f[l],(f[r+1]=pushR(r&gt;mid?f[r]:f[0],g[r+1])))&lt;=k;++r);            for(;merge(f[l],f[r])&gt;k&amp;&amp;l&lt;=mid;++l);            ans=max(ans,r-l+1);        }        if(l&gt;n) break;        l=mid=r;    }    printf(\"%d\\n\",ans);}int main(){    fread(BuF,1,FSIZE,stdin);    int t;    for(read(t);t--;work());    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Graph","Matrix"]},{"title":"HDU2022 D6T8 Shinobu Loves Segment Tree","url":"/post/HDU2022-6-H/","content":"一万种过法。\r\n\r\n题意\r\n以下代码：\r\nvoid build(int id,int l,int r){    value[id]+=r-l+1;    if(l==r) return;    int mid=(r+l)/2;    build(id*2,l,mid);    build(id*2+1,mid+1,r);    return;}long long run(int n,int x){    for(int i=1;i&lt;=n;++i) build(1,1,i);    return(value[x]);}\r\n给出  组询问 ，问 run(n,x)\r\n的返回值。\r\n\r\n思路\r\n找规律。\r\n我们对于同一个  与不同的  进行打表。\r\n然后可以发现首先是若干个 0，然后是一个递增序列（废话）。\r\n对这个递增序列（包括第一项的\r\n0）进行差分，然后发现这个差分很有规律。\r\n具体的，规律如下：\r\n\r\n若  是偶数：\r\n\r\n前  项为\r\n1。\r\n之后为公差为 1 的等差序列，然后将其中每个数重复  次。\r\n\r\n若  是奇数：\r\n\r\n公差为 1 的等差序列，然后将其中每个数重复  次。\r\n\r\n\r\n然后考虑计算 0 的个数，可以二分，然后构造到  的路径。\r\n之后计算是十分简单的。\r\nCODE\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;using ll=long long;const int N=1000010,FSIZE=1&lt;&lt;26;char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}int st[N];ll f(ll r,ll x){    ll re=1;    for(;x;x&gt;&gt;=1) st[++st[0]]=x&amp;1;    for(;r&gt;1&amp;&amp;--st[0];)        if(st[st[0]]){            re=re&lt;&lt;1|1;            r&gt;&gt;=1;        }else{            re&lt;&lt;=1;            r=(r+1)&gt;&gt;1;        }    st[0]=0;    return(re);}ll find_zero(ll x){    ll l=1,r=x,mid;    for(;l&lt;r;)        if(f(mid=(l+r)&gt;&gt;1,x)!=x) l=mid+1;        else r=mid;    return(r);}void work(){    ll n,x,b,ans=0;    read(n);read(x);    b=1ull&lt;&lt;(63-__builtin_clzll(x));    n-=find_zero(x)-1;    if(n&lt;=0){        printf(\"0\\n\");        return;    }    if(!(x&amp;1)){        n+=b&gt;&gt;1;        ans-=b&gt;&gt;1;    }    ans+=(((n/b+1)*(n/b))&gt;&gt;1)*b+n%b*(n/b+1);    printf(\"%lld\\n\",ans);}int main(){    fread(BuF,1,FSIZE,stdin);    int t;    for(read(t);t--;work());    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Math","Unknown"]},{"title":"HDU2022 D6T9 Map","url":"/post/HDU2022-6-I/","content":"题意\r\n\r\n组询问，给定两个矩形，第二个矩形被第一个矩形完全包含且由第一个矩形缩放旋转平移得到，求平面一点使得其变换前后位置不变。\r\n\r\n思路\r\n既然变换方式给了就直接把矩阵做出来。\r\n然后考虑列个方程即可。\r\nCODE\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cassert&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;using db=double;const int N=1000010,FSIZE=1&lt;&lt;26;char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    bool f=1;    for(;48&gt;*InF||*InF&gt;57;f^=*InF++=='-');    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));    if(*InF++=='.') for(db t=1;47&lt;*InF&amp;&amp;*InF&lt;58;x+=(t/=10)*(*InF++-48));    x=f?x:-x;}struct point{    db x,y;    point operator-(point b){return((point){x-b.x,y-b.y});}    db operator+(){return(sqrt(x*x+y*y));}}a[4],b[4];struct matrix{    db a[3][3];    matrix operator*(matrix b){        matrix c;        memset(c.a,0,sizeof(c.a));        for(int i=0;i&lt;3;i++)            for(int k=0;k&lt;3;k++)                if(a[i][k]!=0)                    for(int j=0;j&lt;3;j++)                        c.a[i][j]+=a[i][k]*b.a[k][j];        return(c);    }    bool operator==(matrix b){        for(int i=0;i&lt;3;i++)            for(int j=0;j&lt;3;j++)                if(abs(a[i][j]-b.a[i][j])&gt;1e-6){                    return(0);                }        return(1);    }}p;void solve(db a,db b,db c,db d,db e,db f,db l,db r){    db x=(b*f-c*e)/(a*e-b*d),        y=(c*d-a*f)/(a*e-b*d);    printf(\"%.8f %.8f\\n\",x+l,y+r);}void work(){    read(a[0].x);read(a[0].y);    read(a[1].x);read(a[1].y);    read(a[3].x);read(a[3].y);    read(a[2].x);read(a[2].y);    read(b[0].x);read(b[0].y);    read(b[1].x);read(b[1].y);    read(b[3].x);read(b[3].y);    read(b[2].x);read(b[2].y);    point d=a[2];    for(int i=0;i&lt;4;++i){        a[i]=a[i]-d;        b[i]=b[i]-d;    }    db ang=atan2(b[3].y-b[2].y,b[3].x-b[2].x)-atan2(a[3].y,a[3].x),        dx=+(b[3]-b[2])/+(a[3]-a[2]),dy=+(b[0]-b[2])/+(a[0]-a[2]);    p=(matrix){         cos(ang),sin(ang),0,        -sin(ang),cos(ang),0,                0,       0,1}*      (matrix){      dx, 0,0,       0,dy,0,       0, 0,1}*      (matrix){           1,     0,0,           0,     1,0,      b[2].x,b[2].y,1};    solve(    p.a[0][0]-1,    p.a[1][0],    p.a[2][0],    p.a[0][1],    p.a[1][1]-1,    p.a[2][1],    d.x,d.y);}int main(){    fread(BuF,1,FSIZE,stdin);    int t;    for(read(t);t--;work());    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Geometry","Math"]},{"title":"如何在 OI 中使用哈希表","url":"/post/HowToUseHashMap-in-OI/","content":"是在某次模拟赛的时候写字符串哈希被卡常了搞出来的科技，其实挺简单的，但是好像很多人不知道？\r\nSTL\r\n众所周知，我们有 unordered_map&lt;&gt;\r\n它标准，坚如磐石，对于大多数情况来说足够快（原话来自 Martin\r\n的哈希表基准测试），但是对于某些出题人来说还是太慢了。\r\n直接手写\r\n众所周知，我们有如下手写哈希表：\r\nconst int MO=10000019;struct HashMap{    int p[MO],a[MO];    int&amp; operator[](int x){        int tmp=x%MO;        for(int i=tmp;i&lt;MO;++i)            if(!p[i]||p[i]==x){                p[i]=x;                return(a[i]);            }        for(int i=0;i&lt;tmp;++i)             if(!p[i]||p[i]==x){                p[i]=x;                return(a[i]);            }    }};\r\n这个哈希表非常适合用在字符串哈希这样，键值可以近似地看作完全随机的情况。但是只要数据不太随机（主要在数据结构方面）性能很容易迅速下降。\r\n白嫖\r\n众所周知，我们可以使用如 emhash\r\n这样的第三方哈希表，跑的非常非常快，但是显然这个东西并不太能在合理时间内手写出来。\r\n神秘科技\r\n但是我们有一个不会退化的严格  无序关联结构。\r\n考虑键值范围为 ，有\r\n，不妨假设 ，我们开两级结构，第一级结构只有一个大小为\r\n 的桶，第二级结构为  个  大小的桶。\r\n对于键值拆成两部分，前 \r\n位查找第一级结构的桶，若无该键值则新开一个第二级结构桶，并令第一级结构的桶的对应位置指向该桶。\r\n对于后  位直接在前  位对应的第二级结构桶中查询即可。\r\nflowchart TB    subgraph ton[一级]        direction LR        00[0]        01[1]        02[2]        03[3]        04[4]        05[5]        06[6]        07[7]    end    subgraph ton2[二级]        subgraph 1            10[0]            11[1]            12[2]            13[2]        end        subgraph 2            20[0]            21[1]            22[2]            23[3]        end        subgraph 3            30[0]            31[1]            32[2]            33[3]        end        subgraph 4            40[0]            41[1]            42[2]            43[3]        end        subgraph 5            50[0]            51[1]            52[2]            53[3]        end    end    01 --&gt; 1    03 --&gt; 4    06 --&gt; 2    04 --&gt; 3    02 --&gt; 5\r\n查询/插入/删除均为两次寻址操作，缺点是空间占用是  的（实际上需要对  与 \r\n的空间占用具体分析，由于简单此处略过），以及遍历是 \r\n的（虽然是有序遍历，但是实在太慢了）。\r\n在  时需要\r\n。\r\n看起来非常炫酷，但其实跑不过上面提到的 emhash。\r\nconst int N=100010,A=7;template&lt;typename value&gt;struct HashMap{    int a[1&lt;&lt;(32-A)],size;    value t[N][1&lt;&lt;A];    value&amp; operator[](int x){        if(!a[x&gt;&gt;A]) a[x&gt;&gt;A]=++size;        return(t[a[x&gt;&gt;A]][x&amp;((1&lt;&lt;A)-1)]);    }};\r\nAnything More Exciting?\r\n显然上述方案差不多适用到 unsigned\r\n键值，虽然大多数情况下是足够的，但是局限性还是很大。\r\n扩域的方法我想了很久，在处理冲突上一直没有好的方案，直到我换了一个思路。\r\n考虑键值 ，前  位与后  位分开处理，使用两个上述的哈希表。\r\n先在第一个哈希表中查找前 \r\n位得到权值 （如果没有就赋一个新权值），然后在第二个哈希表查找后\r\n 位得到 （两个哈希表的权值独立）。\r\n然后当前键值就被映射为了 ，再使用一个上述哈希表即可。\r\n每次操作是  次寻址，空间占用为\r\n，考虑到空间占用极大（估计常数也不小），我觉得这个东西完全没有优势区间（雾）。\r\n个人认为最多扩域到 ，拆成前  位（直接等价的转为 ）与后  位，这样在 \r\n的时候可以把最后一个桶的键值值域缩小到 。\r\n","categories":["Note"],"tags":["Hash"]},{"title":"IOI2022 最罕见的昆虫","url":"/post/IOI2022-Insects/","content":"题意\r\n你有 \r\n个元素，种类未知，三种操作：\r\n\r\n选取元素 ；\r\n不选元素 ；\r\n查询选取的元素中，出现最多的种类出现了多少次。\r\n\r\n三种操作均可执行最多 \r\n次，你需要求出所有元素中出现最少的种类出现了多少次。\r\n交互库非自适应。\r\n\r\n思路\r\n先尝试得到种类的数量。\r\n可以先按顺序选取所有元素，如果最多的种类出现了两次，那么就把刚选的元素丢掉，保证每个种类只出现一次。\r\n最后种类数即为选取的元素数，设为 。\r\n然后思考求答案，不妨假设答案为 ，那么显然，每个种类都至少有  个元素。\r\n但是不满足每个种类都至少有 \r\n个元素，也就是说，令每个种类选取  个元素，实际选取的元素数小于 。\r\n这样转化为判定问题，满足可二分性。\r\n实现\r\n但是卡常。\r\n首先你发现向下二分的时候，没选的就用不上了。\r\n同理向上二分的时候，选了的就一直选。\r\n然后二分上界设为 ，这样就几乎可以通过此题。\r\n但是良心出题人枚举了你所有可能的二分实现并构造了数据卡你一分\r\n需要在二分的时候随机加一来扰动避免极端情况。\r\nCODE\r\n#include \"insects.h\"#include&lt;random&gt;#include&lt;chrono&gt;std::mt19937 rnd(std::chrono::steady_clock().now().time_since_epoch().count());namespace {int a[2010],cnt,col;}int min_cardinality(int n){    for(int i=0;i&lt;n;++i){        move_inside(i);        if(press_button()&lt;2){            ++cnt;            a[i]=-1;        }else move_outside(i);    }    col=cnt;    int l=1,r=n/cnt,ans;    for(;l&lt;=r;){        int t=(l+r)&gt;&gt;1;        if((l+r)&amp;1) t+=rnd()&amp;1;        for(int i=0;i&lt;n;++i)            if(a[i]==0){                move_inside(i);                if(press_button()&lt;=t){                    a[i]=1;                    if(++cnt==t*col) break;                }else move_outside(i);            }        if(cnt==t*col){            for(int i=0;i&lt;n;++i)                if(a[i]==1) a[i]=-1;            ans=t;            l=t+1;        }else{            for(int i=0;i&lt;n;++i){                if(a[i]==0) a[i]=-1;                if(a[i]==1){                    --cnt;                    move_outside(i);                    a[i]=0;                }            }            r=t-1;        }    }    return(ans);}\r\n","categories":["Solution"],"tags":["Non-Traditional Problem","Binary Search"]},{"title":"JOISC2020 星座 3","url":"/post/JOISC2020-Constellation/","content":"题意\r\n给定  的直方图与 \r\n个带权关键点，定义两个点有边为它们形成的矩形与直方图无交，求最大权独立集补集的权。\r\n\r\n思路\r\n考虑对于直方图有经典转化，将其看作为笛卡尔树然后自底向上合并。\r\n我们定义关键点  的控制区间为\r\n，满足其中的每个点的直方图高度都小于等于\r\n 的高度，显然，对于 （高度大于 ）跟  有边当且仅当 。\r\n然后进行贪心，考虑我们试着往最大权独立集插入权值为  的点，使得总计权值为  的一些点弹出。\r\n我们设这个  的数组为 。\r\n先假定 ，此时  必然插入，那么我们令 。\r\n\r\n然后考虑 ：\r\n\r\n如果  则不插入（弹出\r\n），因为 \r\n的控制区间肯定比其下的的点要大，更容易冲突，而且没有使答案更优。\r\n如果 \r\n则插入，但是其可能不在最终答案里，考虑这种情况：\r\n5  8#4\r\n最优解显然为保留 ，但是插入\r\n 的时候其会弹出 ，所以我们需要进行撤销操作。\r\n对于上面某个点 ，假定其没有被弹出），其插入有两种情况：\r\n\r\n弹出 ，并且将  放回，这意味着  只与  有连边。这对应为 。\r\n弹出 ，但不将  放回，这意味着  与  都有连边，即在  中。这对应为 。\r\n\r\n于是我们直接令 ，\r\n原有的  会恰好抵消掉。\r\n注意到我们只讨论了 \r\n中仅有一个点的情况，剩余的可以归纳证明。\r\n\r\nCODE\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;using ll=long long;const int N=1000010,FSIZE=1&lt;&lt;24;int n,m,l[N],r[N];ll ans;vector&lt;int&gt; h[N];vector&lt;pair&lt;int,int&gt;&gt; s[N];struct FT{    ll a[N];    void modify(int x,int y,ll c){        a[x]+=c;        a[++y]-=c;        for(;x!=y;)            if(x&lt;y) a[x+=x&amp;-x]+=c;            else a[y+=y&amp;-y]-=c;    }       ll query(int x){        ll re=0;        for(;x;x-=x&amp;-x) re+=a[x];        return(re);    }}t;char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}int get(int *s,int x){return(s[x]?s[x]=get(s,s[x]):x);}int main(){    fread(BuF,1,FSIZE,stdin);    read(n);    for(int i=1,x;i&lt;=n;++i){        read(x);        h[x].push_back(i);    }    read(m);    for(int i=1,x,y,c;i&lt;=m;++i){        read(x);read(y);read(c);        s[y].emplace_back(x,c);    }    for(int i=1;i&lt;=n;++i){        for(auto j:s[i]){            int p=j.first;            ll x=t.query(p);            if(x&lt;j.second){                ans+=x;                t.modify(get(l,p),get(r,p),j.second-x);            }else ans+=j.second;        }        for(auto j:h[i]) l[j+1]=r[j-1]=j;    }    printf(\"%lld\\n\",ans);    return(0);}\r\n","categories":["Solution"],"tags":["Data Structure","Tree","Greedy"]},{"title":"Link-Cut Tree 学习笔记","url":"/post/Link-Cut-Tree/","content":"废话\r\n系统的写一写不然忘了。\r\n考虑树链剖分（或者更细化地、重链剖分），显然不支持删边，因为这样会破坏一整条链上的用于维持复杂度的信息，而我们并没有办法控制这样一条链的长度。\r\n我们直接 非常草率地 使用 Splay 的思想：乱搞\r\n均摊。我们现在把重链剖分的重儿子的定义换一下（常叫偏爱儿子），我们现在选择一条链的方式是：乱选。\r\n姑且用着先，然后选择用一种美妙的数据结构来维护 既然使用了 Splay\r\n的思想当然是 Splay 啦 。\r\n然后再定义 怎么制仗的还有\r\n维护的方式，我们定义一条树上剖出来的排好序的链对应的 Splay\r\n是这条排好序的链使用某种优先级构建成的笛卡尔树是我们维护出来的 Splay\r\n，这个优先级的具体值要看 Splay 的心情 搞不好就变成 Spaly\r\n。\r\n那么我们建树的过程大概就是，随便选择（比如第一个）儿子，然后随便搞成一条链形的\r\nSplay 。\r\n精神恍惚\r\n\r\n好的我们重新用人话解释一下一棵 LCT 的样子。\r\n首先，我们有一棵原树。\r\n然后，我们随便选一个根（不过一般是 1\r\n吧，反正初始化无所谓），然后给每一个点选择一个偏爱儿子（同重链剖分，不过没有具体要求），再把每个有偏爱边形成的链都变成一颗\r\nSplay ，要求 Splay 的中序遍历恰好是对应的链的由下至上的遍历。\r\n我们不需要太在意这些细节，一方面因为这是个势能结构（不然你肯定能见到可持久化\r\nLCT 这种东西），到时候会有各种操作来打磨它的结构；另一方面是 LCT\r\n既然支持加边，这种操作根本就不用实现。\r\n总之，这样我们就得到了由 Splay 形成的森林。\r\n不过我们还忽略了一个问题：Splay 的根的父亲是否需要值呢？\r\n答案是肯定的，否则你没办法用这一堆森林还原出原树来，简单指向原树中这一条链的根的父亲即可。\r\n这样由 Splay 内部的实边（这些边是需要 Splay 来维护的）与 Splay\r\n之间的虚边（这些边是单独维护的）就形成了一棵树。\r\n那么接下来，当我们要询问的时候，我们肯定要把询问的链单独拉出来，这样方便维护。\r\n我们开始定义第一个操作：\r\naccess\r\n这个操作的定义是，令某个结点到当前 LCT\r\n的根的路径变成一条链，其余跟路径上的点有关系的边全部拆开。\r\nvoid access(int x){    for(int y=0;x;x=a[y=x].fa){        splay(x);a[x].s[1]=y;pushup(x);    }}\r\n看上去简短过头了，考虑它的意思。\r\n首先，先把当前结点  旋转至\r\nSplay\r\n的根，那么显然的，它的左子树全都是它现在所在这条链，由它下行的部分，右子树则是由它上行的部分。\r\n于是我们要砍掉左子树，将其赋为 .\r\n接下来，我们要连接  与  在原树中的父亲，因为  已经是 Splay\r\n的根了，所以其父亲就是其在原树中的父亲。这样，我们只需砍掉其父亲所在链中，由其父亲下行的部分，再接到当前结点即可。\r\n发现这个操作与一开始的基本一致，我们把它的父亲旋至 Splay\r\n的根，砍掉左子树，再把左儿子接过来。\r\n在这个过程中不要忘记更新信息。\r\nsplay\r\n多少还是提一下。\r\n#define iss(x) (a[a[x].fa].s[1]==x)bool nroot(int x){    return(a[a[x].fa].s[0]==x||iss(x));}void rotate(int x){    int y=a[x].fa,k=iss(x),&amp;ot=a[x].s[!k];    if(nroot(y)) a[a[y].fa].s[iss(y)]=x;    a[x].fa=a[y].fa;    a[y].fa=x;a[y].s[k]=ot;    a[ot].fa=y;ot=y;    pushup(y);}void splay(int x){    for(int y=st[st[0]=1]=x;nroot(y);st[++st[0]]=y=a[y].fa);    for(;st[0];pushdown(st[st[0]--]));    //下放标记    for(int y=a[x].fa;nroot(x);rotate(x),y=a[x].fa)        if(nroot(y)) rotate(iss(y)^iss(x)?x:y);    pushup(x);}\r\n注意 LCT 有一些标记是需要下传的，但是 Splay\r\n操作前因为不是自顶向下进入的，所以不能保证标记正确，于是我们需要手动将当前点到\r\nSplay 的根上的所有标记自顶向下下放。\r\n注意 rotate 操作要额外使用一个操作判读当前是否是 Splay\r\n的根，因为 LCT 的特性。\r\n因为 LCT 上只有一个结点没有父亲，判断其不为 Splay\r\n的根是只需它是父亲的某个儿子。\r\nmakeroot\r\n这是个有趣的操作。\r\n你发现 access\r\n并不能提取出所有的链，因为显然两个端点可能都不是根，所以我们需要造根。\r\nvoid makeroot(int x){    access(x);splay(x);    flip(x);}\r\nvoid flip(int x){    a[x].rev^=1;    swap(a[x].s[0],a[x].s[1]);}\r\n考虑这为什么是对的。\r\n首先，我们 access 联通了  与当前的根，并把  旋至 Splay 的根。\r\n此时，因为 access 操作保证了整条链上  是深度最深的，而我们又将  旋转至了 Splay 的根，那么现在  的左子树为空。\r\n此时我们将整个 Splay 左右翻转，即做到了右子树为空，即令  变为了 Splay 中深度最小的点，显然  没有父亲，此时  就为整个 LCT\r\n的根。而其他结点的深度翻转，则反转了边的父子关系（注意这个改变不影响树的形态）。\r\n至于不在这条链上的结点，它们的父亲没有改动。\r\n那么此时，我们提取出树上  到\r\n 的链即：\r\nvoid split(int x,int y){    makeroot(x);access(y);    splay(y);}\r\n注意最后的 splay\r\n仅是为了维持平衡，因为它并没有改变什么东西，之后也没有操作。\r\nfindroot\r\n既然我们可以随意换根，那么我们显然需要某种方式找到这个根。\r\n简单的我们可以一路沿着父亲找上去，然后在根所在的 splay\r\n中找到深度最小的结点（最左结点）。\r\n不过为了平衡 偷懒 我们使用 access 与\r\nsplay 操作而非直接找父亲。\r\nint findroot(int x){    access(x);splay(x);    for(;a[x].s[0];pushdown(x),x=a[x].s[0]);    splay(x);    return(x);}\r\nLink-Cut\r\n接下来，经过长长的铺垫我们终于来到看起来最重要的部分。\r\nvoid link(int x,int y){    makeroot(x);    if(findroot(y)!=x) a[x].fa=y;}\r\n首先 makeroot 一下，然后 findroot\r\n一下，这样就可以判断  与  是否联通。\r\nvoid cut(int x,int y){    makeroot(x);    if(findroot(y)==x&amp;&amp;a[y].fa==x&amp;&amp;!a[y].s[0]){        a[y].fa=a[x].s[1]=0;        pushup(x);    }}\r\n首先，注意一下：\r\nint findroot(int x){    access(x);splay(x);    for(;a[x].s[0];pushdown(x),x=a[x].s[0]);    splay(x);    return(x);}\r\n这里面是有一个 access 的。\r\n首先 makeroot findroot\r\n判断联通，然后你注意到，如果它们之间有边，那么 access\r\n之后整条链一定只有它们两个点。所以  必然是  的父亲。\r\n而且整条链上深度比  小的点只有\r\n 一个，且肯定是  的父亲，那么  左子树一定为空（显然右子树经过\r\naccess 后是空的）。\r\n当然，因为整条链上只有两个点，所以维护了 size 的话也可以：\r\nvoid cut(int x,int y){    makeroot(x);    if(findroot(y)==x&amp;&amp;a[x].sz&lt;3){        a[y].fa=a[x].s[1]=0;        pushup(x);    }}\r\n有一个必须要提的地方，如果某些题目中没有 cut\r\n那么维护连通性可以使用并查集以大幅减小常数。\r\nCODE\r\n此代码可以通过 P3690\r\n【模板】动态树（Link Cut Tree） 。\r\n#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int n,m;struct LCT{    int st[100010];    struct node{        int s[2],val,sum,fa;        bool rev;    }a[100010];    #define iss(x) (a[a[x].fa].s[1]==x)    void pushup(int x){        a[x].sum=a[a[x].s[0]].sum^a[a[x].s[1]].sum^a[x].val;    }    void flip(int x){        a[x].rev^=1;        swap(a[x].s[0],a[x].s[1]);    }    void pushdown(int x){        if(a[x].rev){            flip(a[x].s[0]);            flip(a[x].s[1]);            a[x].rev=0;        }    }    bool nroot(int x){        return(a[a[x].fa].s[0]==x||iss(x));    }    void rotate(int x){        int y=a[x].fa,k=iss(x),&amp;ot=a[x].s[!k];        if(nroot(y)) a[a[y].fa].s[iss(y)]=x;        a[x].fa=a[y].fa;        a[y].fa=x;a[y].s[k]=ot;        a[ot].fa=y;ot=y;        pushup(y);    }    void splay(int x){        for(int y=st[st[0]=1]=x;nroot(y);st[++st[0]]=y=a[y].fa);        for(;st[0];pushdown(st[st[0]--]));        for(int y=a[x].fa;nroot(x);rotate(x),y=a[x].fa)            if(nroot(y)) rotate(iss(y)^iss(x)?x:y);        pushup(x);    }    void access(int x){        for(int y=0;x;x=a[y=x].fa){            splay(x);a[x].s[1]=y;pushup(x);        }    }    void makeroot(int x){        access(x);splay(x);        flip(x);    }    int findroot(int x){        access(x);splay(x);        for(;a[x].s[0];pushdown(x),x=a[x].s[0]);        splay(x);        return(x);    }    void split(int x,int y){        makeroot(x);        access(y);splay(y);    }    void link(int x,int y){        makeroot(x);        if(findroot(y)!=x) a[x].fa=y;    }    void cut(int x,int y){        makeroot(x);        if(findroot(y)==x&amp;&amp;a[y].fa==x&amp;&amp;!a[y].s[0]){            a[y].fa=a[x].s[1]=0;            pushup(x);        }    }}t;char BuF[1&lt;&lt;26],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    bool f=1;    for(;47&gt;*InF||*InF&gt;58;f^=*InF++=='-');    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(*InF++^48));    x=f?x:-x;}int main(){    fread(BuF,1,1&lt;&lt;26,stdin);    read(n);read(m);    for(int i=1;i&lt;=n;++i){        read(t.a[i].val);        t.a[i].sum=t.a[i].val;    }    for(int i=1,c,x,y;i&lt;=m;++i){        read(c);read(x);read(y);        if(c==0){            t.split(x,y);            printf(\"%d\\n\",t.a[y].sum);        }else if(c==1) t.link(x,y);        else if(c==2) t.cut(x,y);        else{            t.splay(x);            t.a[x].val=y;            t.pushup(x);        }    }    fclose(stdin);    fclose(stdout);    return(0);}\r\n总结\r\nLCT 现在应该不会考了，毕竟大纲放在那（\r\nLCT 的时间复杂度均摊是 \r\n的，但实战中比重链剖分慢得多。能不用就别用这玩意，真心慢，各种细节多的很。\r\n然后比重链剖分还有一个劣势，做不了子树问题，硬要做的话有限制而且复杂。\r\n你要真想整一个完整版可以去学 Top Tree\r\n嗯放道简单的习题在这：\r\nNOI2014 魔法森林\r\n","categories":["Note"],"tags":["Data Structure","Link-Cut Tree"]},{"title":"PKUSC 2023","url":"/post/PKUSC-2023/","content":"OI 生涯快结束了，毕竟这么菜进省队是很难的了，大概是最后一次\r\nPKUSC。\r\n\n        \n            \n            \n            未记录的 PKUSC 2021\n        \n        不知道为什么当时没写，现在补一下吧，很怀念但不怎么记得了。\r\nD0\r\n同去的高一大佬有 GMH RHX HGD ZRH。\r\n飞机延误 2h，在机场带着新入坑的两个学长打方舟，看着 RHX 的 3\r\n级号表示不可能推活动，机场人很多所以做\r\n在窗台上。\r\n第一次坐飞机耳朵比较难受。\r\n晚上因为太菜被嘲讽了两次。\r\n跟 RHX 住一个房间，他号上 1000+ 理智于是晚上帮他推进度。\r\n酒店的床头柜里放了两本王阳明相关。\r\nD1\r\n早上去余姚中学报道，到门口的时候玩了佘桃的梗。\r\n中午吃的 M 记。\r\n下午的比赛 T1 是签到，想了一些性质然后 1.5h 切了，用了三个数。\r\nT2 写了个 44 暴力。\r\nT3 最后没冲出来。\r\n晚上是 ZRH\r\n带我们去吃面，不过我比较的保守没有点余姚特色（#查询精神状态）。\r\n继续帮 RHX 推进度。\r\nD2\r\n早上合影完去 NOI 场地参观，比较处刑毕竟我菜。\r\n中午还是吃 M 记，抽卡 150 发的时候出了第三个蒂蒂。\r\nT1 不会 T2 不会 T3 不会，好像拿了大概 40pts？忘了。\r\n晚上教练给了我们 300RMB 去吃好吃的。ZRH\r\n对着地图推荐找了一家，价格看上去很正常，然后发现分量实在有点少，总之 300\r\n果然不够。\r\n花 1.5h 冲到了光谱 18。晚上是覆潮之下最后一天，帮 RHX\r\n拿到了二队长，过了切城剿灭。\r\nD3\r\nHGD GMH 去面试了，剩下的回酒店摸鱼。\r\n中午吃的肯德基（怎么全是这种东西），奶茶不错。\r\n晚上在机场推光谱 19，2h 没推出来，乐（后面新约推到 25 了）。\r\n飞机晚点到了 22:30，回到学校刚好零点。\r\n\n        \r\nD0\r\n好耶北京，去年疫情一弄不知道什么玩意。\r\n晚上吃饭教练请到了三位北大的学长和一位清华的学长来聊天，场面一度十分尴尬，然后一度十分混乱。\r\n呜两分钟没看剿灭崩了。\r\n晚上通了 TNO 云南，确认了一个简单运营。\r\nD1\r\n上午试机发现是两年前 D1T1，然后花了 40min，感觉没救。\r\n北大饭堂好啊。\r\n\r\nT1 串串题，有点慌，毕竟科技树只点了 KMP，Manacher 还有没真正写过的\r\nSA。\r\n看完后两题之后花十几分钟写了 54pts KMP，然后想到了一个 SA\r\n做法。但是自己并没有背过\r\nSA，于是开始手搓，搓了一个小时竟然搓出来了（感觉常数很好， 只有五倍常数）。\r\n然后发现做法假了。自闭，一直自闭到比赛结束。\r\nT2 想了想状压，然后因为 T1 自闭了只想到了  状压（#查询精神状态）。\r\nT3 写了 32pts，儿子少于 \r\n是会做的，但是没时间写了。\r\n出来问了下 T1 CZJ 写了线性的 EXKMP，JRZ 写的哈希。\r\n仔细想想发现 SA 也能做的，沮丧。\r\n\r\n下午逛了未名湖，拿飞机餐的饼干喂鸭子，拍到了白鹭。\r\n北大的鸭子飞得好高。\r\nD2\r\n早上的讲座看 TNO 文本。\r\n然后逛了一下北大。\r\n\r\nT1 看了一下，感觉很可做，仔细分析发现是 ETT 板子题，虽然之前没写过\r\nETT 但感觉不会很难写。\r\n大概写了 1.5h，拍了两组，调了 0.5h 过了。\r\nT2\r\n非常乱搞，所以先随便写了个估价函数，然后交了个暴力，然后开始胡乱调整。\r\n先试了试随机调整，拿到了 35pts，然后改成了每次调整最大的，突然就有\r\n50pts 了。\r\n后面看完 T3 回来随便写了些东西，最后总之是没有结果。\r\n跑出来是 TLE，要是时限开大 100 倍应该能切\r\nT3\r\n第一次开题看到好像有二次剩余先跳了，后面发现好像可以枚举根号，但是又发现这个根号是定义在实域上的，不会了。\r\n坐牢 1h 润了。\r\n\r\n出来问了一下发现我竟然是 JZ 最高的？JRZ 和 CZJ 都没过\r\nT1。阿巴阿巴靠数据结构翻了点盘。\r\nD3\r\n大早上起床发现迟了，要寄要寄要寄。\r\n去机场坐的神秘路线地铁，你说它神秘吧，确实是曼哈顿意义上的最短路，你说它正常吧，明明不用换乘的……\r\n到机场之后坐了一会，上飞机之后发现很困，后面一直在睡觉。\r\n\r\n感觉这次 PKUSC\r\n不是很好，签到题没签上，虽然总分比前两年还是高了不少，但毕竟是一道\r\nETT 板题欸。\r\n得从头补字符串和数学了，简单技巧和简单结论都没怎么见过。\r\n","categories":["Record"],"tags":["Log"]},{"title":"POI2013 LAB-Maze","url":"/post/POI2013-LAB-Maze/","content":"题意\r\n给定一个长度为  的仅由  构成的序列，描述一个包含\r\n\r\n个点的、边与坐标轴平行的逆时针简单多边形，其中  表示往左拐， 表示往右拐，可能无解。\r\n\r\n约定\r\n 表示 “ 的数量”， 同理。\r\n具体表示全局或是某个区间内的应该可以通过上下文推导。\r\n所有图片仅供示意，实际运行时（应该）都不会出现。\r\n思路\r\n首先我们来判定有无解。\r\n不管是原文题面还是翻译题面都没有提到多边形是逆时针的，幸好有好心人在讨论区提供了一份\r\nSPJ 并且十分可以研读，不然我估计这辈子玩不明白 90 分是什么玩意。\r\n那么显然，有解的情况当且仅当 。\r\n\r\n然后我们来考虑选取四个 \r\n作为整个多边形的端点，要求满足两个  之间 ，这样我们可以考虑先把这中间四部分构造出来，然后再拼起来。\r\n\r\n为什么是 \r\n呢，你发现这样的一个区间满足一个性质，初始方向和结束方向是相同的，所以从某种意义上，我们可以将这样一个区间构造出来的图形，视作为一个非常非常粗的线段。\r\n这也是我们之后一定能在四个端点处将这四个图形拼起来的原因：把这四段视作为线段，最后相当于构造一个矩形。\r\n\r\n那么满足了 ，我们发现我们可以将区间视作为一个类似于括号序的结构，不难发现可以由以下方法构造：\r\n\r\n在两端增加一对相反的方向。\r\n合并两个区间。\r\n\r\n具体的维护可以维护一个矩形，其延伸出两条线段：\r\n\r\n\r\n中间的部分仅作示意，我们实际维护的时候只维护那两个端点延伸出来的线段。\r\n\r\n然后对于增加两个相反的方向的操作，那么就是将线段转向，延伸到矩形以外，然后旋转\r\n：\r\n\r\n然后对于合并两个矩形的操作：\r\n\r\n我相信已经不需要我过多解释这些是什么意思了，三张图很清楚了。\r\n\r\n然后考虑得到了四块矩形以及八个端点，如何合并。\r\n显然 \r\n端点对应的点应该是 上一个矩形的右端点延伸出来的边，以及\r\n下一个矩形的左端点延伸出来的边 的交点。\r\n我们不妨令 下一个矩形的左端点延伸出来的边\r\n立刻旋转一次（固定该 \r\n端点位置），然后直接伸长接到 上一个矩形的右端点延伸出来的边\r\n上，这样只需要延伸得足够长，即可保证这两个矩形无交。\r\n见下图：\r\n\r\n那么接下来来到最后一步，我们这样构造的图形很可能不是闭合的。\r\n这也很简单，我们只需要按照流程模拟一遍，最后通过起点与终点的坐标差微调一下长度即可：\r\n\r\n例如在上图中，我们应该加长线段 \r\n与线段 。\r\n只要我们保证我们每次是加长两根线段，就可以确保修正之后不会发生重合。\r\n当然你也可以试着去直接对着矩形维护出来的信息硬算，我试过，放弃了\r\n实现\r\n思路不难，实现起来细节很多。\r\n一开始可以将左边的若干个  移到最右段，这样令第一个字母是 ，这样可以防止最后一个区间被拆成两个。\r\n我们可以将我们需要维护的矩形封装一下，维护以下信息：\r\nstruct sqr{    int w,  // 宽度        h,  // 高度        lx, // 左端点延伸线段的长度        ly, // 右端点延伸线段的长度        nx, // 左端点延伸线段的在答案序列中的编号        ny, // 右端点延伸线段的在答案序列中的编号        x,  // 左端点延伸线段的位置        y;  // 右端点延伸线段的位置};\r\n如下图所示：\r\n\r\n然后对于添加两个方向的操作：\r\n// 0 表示左端点左转，1 表示左端点右转sqr operator^(bool b){    // 转向之后左右两条边的长度就固定了，丢到答案上    if(!len[nx]) len[nx]=lx;    if(!len[ny]) len[ny]=ly;        return(sqr{h,               w+2,       // 旋转 90 度之后长宽互换，并且高度 +2               b?h-x+1:x,               b?y:h-y+1, // 按照方向讨论一下，这里不放图了自己手画一下               nx-1,               ny+1,      // 编号移动一下               b?1:w+2,               b?w+2:1    // 位置调整，自己手画一下              });}\r\n然后合并两个区间：\r\nvoid operator+=(const sqr &amp;b){    if(!len[ny]) len[ny]=ly+b.lx-1;  // 将两个线段无转角地合并    *this=sqr{w+b.w,                 // 宽度直接相加              max(h-y,b.h-b.x)+               \t  max(y,b.x),        // 高度注意中间合并的线段位置会对结果造成影响              lx,b.ly,nx,b.ny,       // 复制信息              x+max(b.x-y,0),              b.y+max(y-b.x,0)       // 修正新的位置             };}\r\n\r\n实际上我写的时候写的是一个搬的题，那题加了一个可以选择添加一个额外拐点（这个非常阴间），然后多组数据，然后可以顺时针，还要求离散化，但是\r\n。\r\n徒增大量细节，不知道搬题人怎么想的\r\nCODE\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=100010,FSIZE=1&lt;&lt;20,fx[4][2]={{-1,0},{0,1},{1,0},{0,-1}};int n,len[N],sts;struct{    int x;    // 该层对应的矩形编号    bool y;   // 该层外面两边的方向}st[N];       // 栈struct point{int x,y;}ans[N];vector&lt;int&gt; a;bool s[N];struct sqr{    int w,h,lx,ly,nx,ny,x,y;    void operator+=(const sqr &amp;b){        if(!len[ny]) len[ny]=ly+b.lx-1;  // 将两个线段无转角地合并        *this=sqr{w+b.w,                 // 宽度直接相加                  max(h-y,b.h-b.x)+                      max(y,b.x),        // 高度注意中间合并的线段位置会对结果造成影响                  lx,b.ly,nx,b.ny,       // 复制信息                  x+max(b.x-y,0),                  b.y+max(y-b.x,0)       // 修正新的位置                 };    }    // 0 表示左端点左转，1 表示左端点右转    sqr operator^(bool b){    // 转向之后左右两条边的长度就固定了，丢到答案上    if(!len[nx]) len[nx]=lx;    if(!len[ny]) len[ny]=ly;        return(sqr{h,               w+2,       // 旋转 90 度之后长宽互换，并且高度 +2               b?h-x+1:x,               b?y:h-y+1, // 按照方向讨论一下，这里不放图了自己手画一下               nx-1,               ny+1,      // 编号移动一下               b?1:w+2,               b?w+2:1    // 位置调整，自己手画一下              });    }}d[N];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;*InF&lt;33;++InF);    for(x=0;*InF&gt;32;x=x*10+(*InF++^48));}sqr solve(int l,int r){    if(l&gt;r)        return(sqr{0,1,0,0,0,0,0,0});    for(d[0]=sqr();l&lt;=r;++l){        if(sts&amp;&amp;s[l]!=st[sts].y){   // 这里需要魔改一下括号序的弹栈规则            if(!d[sts--].w){        // 如果下一层矩形为空                d[sts+1]={1,2,1,1,l-1,l+1,s[l]?1:2,s[l]?2:1};                len[l]=1;            }else                d[sts+1]=d[sts+1]^s[l];    // 旋转            if(!d[sts].w)                d[sts]=d[sts+1];    // 如果当前层矩形为空直接复制            else                d[sts]+=d[sts+1];   // 否则合并            d[sts+1]=sqr();        }else{            st[++sts]={l,s[l]};            d[sts]=sqr();        }    }    return(d[0]);}void calc(int m){    // 按照当前的长度情况模拟出答案各点的坐标    ans[m]={0,0};    for(int i=m,f=0;i&lt;=n;++i){        ans[i+1]={ans[i].x+fx[f][0]*len[i],ans[i].y+fx[f][1]*len[i]};        if((s[i]?++f:--f)&gt;3) f=0;        else if(f&lt;0) f=3;    }}void work(){    int L=0,R=0,m=1,p=0;    for(int i=1;*InF&gt;32;(s[i++]=*InF++=='P')?++R:++L,++n);    if(L-R!=4){        printf(\"NIE\\n\");        return;    }    // 将左边的 R 移到右边    for(a.clear();s[m];s[++n]=s[m++]);    // 找到四个端点    for(int i=m,d=0;a.size()&lt;4;++i)        if(!d&amp;&amp;s[i]==s[m]) a.push_back(i);        else s[i]==s[m]?++d:--d;    // 计算四个矩形    len[a[0]]=(solve(a[0]+1,a[1]-1)^0).lx+N;    len[a[1]]=(solve(a[1]+1,a[2]-1)^0).lx+N;    len[a[2]]=(solve(a[2]+1,a[3]-1)^0).lx+N;    len[a[3]]=(solve(a[3]+1,n     )^0).lx+N;    // 进行一次模拟    calc(m);    // 修正 x    if(ans[n+1].x&gt;0)        len[a[0]]+=ans[n+1].x;    else        len[a[2]]-=ans[n+1].x;    // 修正 y    if(ans[n+1].y&gt;0)        len[a[1]]+=ans[n+1].y;    else        len[a[3]]-=ans[n+1].y;    // 计算答案    for(calc(m);m&gt;1;ans[--m]=ans[n--]);    for(int i=m+p;i&lt;=n;++i) printf(\"%d %d\\n\",ans[i].x,ans[i].y);}int main(){    fread(BuF,1,FSIZE,stdin);    work();    return(0);}\r\n","categories":["Solution"],"tags":["Construction"]},{"title":"RMQ 合集","url":"/post/RMQ/","content":"upd 2021/9/20： 更新。\r\n暴力想必算了。\r\n倍增\r\n或 Sparse Table。\r\n考虑  表示  ，显然可以  。\r\n但是因为 RMQ 问题满足可重复贡献（即 ），所以我们并不需要把 \r\n个区间完美的拼起来，只需要找到两个足够长的区间使它们拼起来能覆盖整个需要的区间即可，所以\r\n。\r\nfor(int j=1;j&lt;=log2[n];++j)    for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)        f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);for(int i=1;i&lt;=m;++i){    int x=read(),y=read(),s=log2[y-x+1];    printf(\"%d\\n\",max(f[x][s],f[y-(1&lt;&lt;s)+1][s]));}\r\n线段树等数据结构\r\n\r\n代码想必算了。\r\n猫树\r\n线段树的变种。\r\n对每个树上结点维护前后缀，用 zkw 的方式补全线段树，然后快速算 LCA\r\n什么的。\r\n\r\n代码会了但是没必要放这里。\r\nFour Russians\r\n首先把整个序列分成  块，然后做 ST 表。\r\n这样可以把询问分成中间一堆整块，这个可以  ，与两边的散块（或者一个散块）。\r\n对于散块怎么办呢？\r\n再跑一个 ST 表。\r\n\r\n没写过。\r\n约束 RMQ\r\n敲黑板：这个是 \r\n的。\r\n首先要跑这个东西需要满足一个条件：相邻两数差的绝对值必须为\r\n1（我们一会会去掉这个条件）。\r\n首先考虑 Four Russians\r\n算法，我们发现如果询问有两个散块的话，再对散块使用 ST 表就很蠢了。\r\n我们直接处理一个前缀和后缀就可以加速到 .\r\n然后考虑两端点在同一块里面的情况。\r\n你思考因为相邻两数差的绝对值为 1，所以差分之后就变成一堆 1 与 -1\r\n。这些形成的序列形成的不同的序列显然只有 \r\n种，然后有一个很棒的性质，差分后相同的序列，对于一个区间询问，最值的位置一定是固定的。\r\n似乎没什么用，但我们可以把块弄的更小些：，然后就会有 。\r\n暴力预处理所以本质不同的块，得到每个区间询问的答案，可以做到 。\r\n实际上可以进一步调整块长来均摊（当然你要是闲得慌也可以写 ST\r\n处理），不过没什么用。\r\n然后我们思考怎么把一般 RMQ 转化为约束 RMQ。\r\n首先，我们把序列变成一颗笛卡尔树，这样 RMQ 就变成了\r\nLCA，然后对这颗树跑一个欧拉序，那么显然就有相邻两个数差的绝对值为\r\n1。\r\n代码没有因为不实用。\r\n2021/9/20 更新： emm，我星期三学完的约束 RMQ\r\n星期日就直接出现在了初赛考题里。狂暴押题组长\r\n基于状态压缩的伪线性 RMQ\r\n我们发现 Four Russians 的瓶颈在于对块内求 RMQ。\r\n我们考虑单调栈。\r\n啊单调栈有什么性质呢？\r\n越靠前的越大，而且单调栈中的顺序肯定是原先的顺序。\r\n那么如果我们要在单调栈上维护一个后缀，就直接找到在单调栈中第一个在位置上超过某个数的就行。\r\n例如 3 6 2 5 4 1 的单调栈为 6 5 4 1\r\n然后我们要找到 3 的后缀最大值就是 6\r\n，2 的后缀最大值就是 5。\r\n意会意会真的简单\r\n但是这样只维护了一个后缀，那么右端点的问题就……直接对每个后缀维护一个单调栈。\r\n然后你成功的得到了一个  的东西。\r\n不过，你发现如果我们把这个东西套到 Four Russians 里面还是可以搞出一个\r\n\r\n的东西的。\r\n但是还是非常非常费拉\r\n然后我们注意到 ，所以我们考虑把单调栈变为一个表示某个数是否在栈内的零一序列，然后用个整数压起来，这样就可以避免预处理的时候要复制整个栈带来的时间复杂度。\r\n\r\n然后我们祭出一个在今年终于可以使用的东西：builtin。\r\n我们主要使用 __builtin_ctz （二进制后缀 0 的个数）与\r\n__builtin_clz （二进制前导 0 的个数）（只用一个也行）。\r\n\r\n显然 \r\n那么就是 \r\n代码（根据 OI-Wiki 改的，没什么区别）：\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define uni unsigned#define reg registerusing namespace std;const int N=1e5+5,M=20,FSIZE=1&lt;&lt;26;int m,st[21];char BuF[FSIZE],*InF=BuF,WuF[FSIZE],*OnF=WuF;int read(){    uni x=0;    for(;47&gt;*InF||*InF&gt;58;++InF);    for(;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));    return(x);}void write(reg uni x){    if(!x) *OnF++=48;    for(;x;x/=10) st[++st[0]]=x%10;    for(;st[0];*OnF++=st[st[0]--]^48);    *OnF++='\\n';}struct RMQ{    int n,A[N],BS,S[N][M],Pow[M],Log[N],in[N],Pos[N],Pre[N],Sub[N],F[N];    void buildST(){        int cur=0,id=1;        Pos[0]=-1;        for(int i=1;i&lt;=n;++i) {            S[in[i]=id][0]=max(S[id][0],A[i]);            Pos[i]=in[i-1]==in[i]?Pos[i-1]+1:0;            if(++cur==BS){                cur=0;                ++id;            }        }        id-=!(n%BS);        for(int i=Pow[0]=1;i&lt;M;++i) Pow[i]=Pow[i-1]&lt;&lt;1;        for(int i=2;i&lt;=id;++i) Log[i]=Log[i&gt;&gt;1]+1;        for(int i=1;i&lt;=Log[id];++i)            for(int j=1;j+Pow[i]-1&lt;=id;++j)                S[j][i]=max(S[j][i-1],S[j+Pow[i-1]][i-1]);    }    void buildSubPre(){        for(int i=1;i&lt;=n;++i)            Pre[i]=in[i]==in[i-1]?max(Pre[i-1],A[i]):A[i];        for(int i=n;i;--i)            Sub[i]=in[i]==in[i+1]?max(Sub[i+1],A[i]):A[i];    }    void buildBlock(){        static int S[N],top;        for(int i=1;i&lt;=n;++i){            if(in[i]!=in[i-1]) top=0;            else F[i]=F[i-1];            while(top&amp;&amp;A[S[top]]&lt;=A[i]) F[i]^=1&lt;&lt;Pos[S[top--]];            F[S[++top]=i]|=1&lt;&lt;Pos[i];        }    }    void init(){        for(int i=1;i&lt;=n;++i) A[i]=read();        BS=log2(n)*1.5;        buildST();        buildSubPre();        buildBlock();    }    int queryMax(int l, int r) {        int bl=in[l],br=in[r];        if(bl!=br){            int ans1=0;            if(br-bl&gt;1){                int p=Log[br-bl-1];                ans1=max(S[bl+1][p],S[br-Pow[p]][p]);            }            return(max(ans1,max(Sub[l],Pre[r])));        }else return(A[l+__builtin_ctz(F[r]&gt;&gt;Pos[l])]);    }}R;int main(){    fread(BuF,1,FSIZE,stdin);    R.n=read();m=read();    R.init();    for(int i=0,l,r;i&lt;m;++i){        l=read();r=read();        write(R.queryMax(l,r));    }    fwrite(WuF,1,OnF-WuF,stdout);    return(0);}\r\n二次分块实现方式\r\n自己随意口胡的。\r\n这个二次分块实现主要是查询的时候常数更小，大约 1000000\r\n的  会比 ST 表实现快 ，预处理慢一些。\r\n没什么好说的，把 ST\r\n表换成根号分块套根号分块，然后对每一层分块暴力求块间答案。\r\n时间复杂度 ，这里需要注意的是当\r\n 的时候就必须使用\r\nlong long 了，损失的性能基本可以忽略不计，然后可以支持\r\n\r\n，不是很大，但能用就行。\r\n然后就是 __builtin_ 函数的 long long\r\n版本就直接在后面加 ll 就行，例如\r\n__builtin_ctzll 。\r\n代码：\r\n#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define uni unsigned#define reg registerusing namespace std;const int N=1000010,T0=1010,T1=34,FSIZE=1&lt;&lt;26;int n,m,st[21];char BuF[FSIZE],*InF=BuF,WuF[FSIZE],*OnF=WuF;int read(){    uni x=0;    for(;47&gt;*InF||*InF&gt;58;++InF);    for(;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));    return(x);}void write(reg uni x){    if(!x) *OnF++=48;    for(;x;x/=10) st[++st[0]]=x%10;    for(;st[0];*OnF++=st[st[0]--]^48);    *OnF++='\\n';}struct rmq{    int a[N],b0[T0][T0],b1[T0][T1][T1],in0[N],in1[N],p0[N],n0[N],p1[N],n1[N],pos[N],ms,B0,B1;    uni st[N],we[N];    rmq(reg int n){        B1=sqrt(B0=sqrt(n));        for(reg int i=0,x,y,z;i&lt;n;++i){            y=in1[i]=(z=i-(x=in0[i]=i/B0)*B0)/B1;            pos[i]=z%B1;            b0[x][x]=max(b0[x][x],a[i]=read());            b1[x][y][y]=max(b1[x][y][y],a[i]);        }        ms=in1[B0-1];#define rep(s,p,r) for(reg int k=p+1;k&lt;=r;++k) s[p][k]=max(s[p][k-1],s[k][k]);        for(reg int i=0;i&lt;in0[n-1];++i) rep(b0,i,in0[n-1]);        for(reg int i=0;i&lt;=in0[n-1];++i)            for(reg int j=0;j&lt;=ms;++j) rep(b1[i],j,ms);#define get(t,s,x,y) t[x]=a[i];if(s[x]==s[y]) t[x]=max(t[x],t[y]);        p0[0]=p1[0]=a[0];        for(reg int h=0,i=st[0]=1;i&lt;n;++i){            get(p0,in0,i,i-1);            get(p1,in1,i,i-1);            if(in1[i]==in1[i-1]) st[i]=st[i-1];            else h=i;            for(reg uni &amp;x=st[i],tp;x&amp;&amp;a[h+(tp=31-__builtin_clz(x))]&lt;a[i];x^=1u&lt;&lt;tp);            st[i]|=we[i]=1u&lt;&lt;pos[i];        }        for(reg int i=n-1;~i;--i){            get(n0,in0,i,i+1);            get(n1,in1,i,i+1);        }    }    int query(int x,int y){        return(in0[x]!=in0[y]?max(b0[in0[x]+1][in0[y]-1],max(n0[x],p0[y])):            in1[x]!=in1[y]?max(b1[in0[x]][in1[x]+1][in1[y]-1],max(n1[x],p1[y])):            a[x+__builtin_ctz(st[y]&gt;&gt;pos[x])]);    }};int main(){    fread(BuF,1,FSIZE,stdin);    n=read();m=read();    for(static rmq a(n);m;--m){        int x=read()-1,y=read()-1;        write(a.query(x,y));     }    fwrite(WuF,1,OnF-WuF,stdout);    return(0);}\r\n","categories":["Note"],"tags":["Data Structure"]},{"title":"Code+2020 F 六元环 与二叉树旋转","url":"/post/Solution-CodePlus2020F/","content":"upd\r\n2023/5/31：对本文所述结构有了更为本质的认识，故重构。\r\nupd 2023/6/1：换上了新的代码，勘误。\r\n\r\n本题解旨在提供一种维护二叉树旋转信息的非 LCT\r\n做法。对于本人而言，做法来源是退役学长 yyt\r\n的出题莱斯特城，祝其人生之路璀璨。\r\n\r\n题意\r\n给定序列 \r\n其中 。\r\n定义图  中结点  满足  间有双向边当且仅当  是  前第一个大于等于  的数，或  是  后第一个大于  的数。\r\n每次修改将某个 \r\n中的某个数 ，修改后询问  中的六元环数量。\r\n题意转化\r\n首先，容易想到使用笛卡尔树维护序列 ，显然笛卡尔树上的边全部在 \r\n中，然后存在额外连边，它们满足在笛卡尔树上是一个转折的关系（左儿子的右链连向自己，与右儿子的左链连向自己），容易发现\r\n 为一个平面图。\r\n对于六元环，其在 \r\n上由四个三角形组成，通过对这四个三角形的联通情况进行分类讨论可以发现，一组联通的四个三角形与六元环间恰好存在对应关系。\r\n我们用一个三角形在笛卡尔树中最深的结点表示这个三角形，即可将一组联通的四个三角形进一步转化为在笛卡尔树上的联通的四个点。\r\n注意不存在边 ，需要将根节点删除。\r\n如果不存在修改，该计数可以在每个点向下记录下一层结点数与下下层结点数解决，我们接下来考虑如何修改。\r\n\r\n由于修改只会变大，且中序遍历不变，于是这可以描述为修改点在笛卡尔树上进行上旋。\r\n现在有一个结点  父亲为  旋转到原先  的位置，\r\n满足过程中旋转方向不变，对于笛卡尔树上的边仅有 ，\r\n的一个儿子、、 与其的父亲它们的 \r\n的父子关系被改变，同样的贡献的改变量也是  的。\r\n我们假设这之后 \r\n的旋转方向改变，那么称 \r\n是一个转折点。\r\n对于转折点的数量，lxl 通过势能分析证明了其复杂度为 ，不过笔者并未看到具体的证明过程，加上太菜了以及不是本文重点\r\n故先咕这，不补了好像直接套 LCT 的分析就行，但是我不会分析 LCT\r\n而且找不到资料。\r\n数据结构\r\n这显然是可以使用 LCT\r\n维护的，但是毕竟本题的结构较为静态（中序遍历不变），考虑是否存在更为简单的方式。\r\n现在考虑一个大根笛卡尔树，其结点上有权值，为了避免文字太多导致疲劳记为\r\n 吧。\r\n对于结点 ，不妨设是父亲的左儿子，那么它向上第一个转折点的父亲在它的左边，且一定是左边第一个\r\n 大于它的  的点，这中间的其他结点均为  的后代。\r\n对于旋转不到转折点的情况，由于旋转方向上那一条链所有大于  的结点的 \r\n按顺次为一个递减序列（因为它们按顺序是  的祖先），而其他点的  均小于其临近的两个链上的结点的 。\r\n这是什么？单调性，二分一下。不单调的都不是我们要找的，并且会被我们要找的给挡住，所以可以直接查找最终要旋转到的值。\r\n所有的找某个结点的操作均可在数据结构上二分解决，由于本题没有其它操作了，使用线段树维护即可。\r\n拓展\r\n对于一般的二叉树，我们仍然可以使用该方法。\r\n对于一棵二叉树，其满足是自己深度的中序遍历构建的笛卡尔树，对于连续的不变向旋转，可以等价于两个区间操作（以左旋为例）：\r\n\r\n从链顶的子树最左到这个点父亲的所有点深度加一。\r\n这个点的子树中不包括左子树的所有点的深度减去旋转次数。\r\n\r\n实际上可以随便构造序列，只要满足笛卡尔树的性质即可，使用深度便于处理向上旋转某个特定次数的情况。\r\n一般而言这类维护转折的题目不太可能出现区间修改一类的操作，所以区间加是不太可能跟什么别的标记冲突的。\r\n后记\r\n可以看到通过这种方式，我们将旋转操作的维护静态化了。虽然并不能够得到一个更加强大的做法，因为该做法仍然依赖于操作中信息的改变量是有限的这一事实，而对于树本身形态的维护是不能超过动态树的能力范畴的。\r\n虽然只使用了线段树，但由于 LCT\r\n本身结构的特点适于维护树链，相比之下这种做法细节相当多，并不容易调试。\r\n速度由于线段树二分的递归结构在本题上没有太多优势，可以写\r\nzkw 线段树，实际总用时跑到 LCT\r\n的一半（于是完全看不懂洛谷怎么算的总用时了）。\r\n\r\n本文撰文仓促，难免有错误，若发现请务必吊打笔者。\r\n由于笔者没有进行进一步的研究，如果有其它有趣的想法欢迎讨论。\r\nCODE\r\n就这道题的话，代码或许以后补一份\r\n代码有啦。\r\n换成 zkw 线段树了。\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;using ll=long long;const int N=(1&lt;&lt;19)+10,FSIZE=1&lt;&lt;24;int n,m,ans,rt,sl[N],sr[N],fa[N],down[N][2],now[N];vector&lt;int&gt; s;ll p[N];struct ST{    ll a[N+N];    int len;    void build(){        len=(2&lt;&lt;__lg(n-1))-1;        for(int i=1;i&lt;=n;++i) a[i+len]=p[i];        for(int p=len;--p;a[p]=max(a[p&lt;&lt;1],a[p&lt;&lt;1|1]));    }    int pre(int x,ll y){        for(x+=len;x&gt;1;x&gt;&gt;=1)            if(a[(x&gt;&gt;=__builtin_ctz(x))^1]&gt;=y) break;        if(x&lt;2) return(0);        for(x^=1;x&lt;=len;)            if(a[x=x&lt;&lt;1|1]&lt;y) x^=1;        return(x-len);    }    int nxt(int x,ll y){        for(x+=len;x&gt;1;x&gt;&gt;=1)            if(a[(x&gt;&gt;=__builtin_ctz(~x))^1]&gt;y) break;        if(x&lt;2) return(0);        for(x^=1;x&lt;=len;)            if(a[x&lt;&lt;=1]&lt;=y) x|=1;        return(x-len);    }    void add(int x,int y){for(a[x+=len]+=y;x&gt;&gt;=1;a[x]=max(a[x&lt;&lt;1],a[x&lt;&lt;1|1]));}}t;char BuF[FSIZE],*InF=BuF,WuF[FSIZE],*OnF=WuF,ST[10],*STC=ST;template&lt;typename T&gt;void read(T &amp;x){    for(;*InF&lt;33;++InF);    for(x=0;32&lt;*InF;x=x*10+(*InF++^48));}void write(int x){    for(!x&amp;&amp;(*OnF++=48);x;x/=10) *++STC=x%10^48;    for(;STC!=ST;*OnF++=*STC--);    *OnF++='\\n';}int calc(int x){    int *w=down[x],*ls=down[sl[x]],*rs=down[sr[x]],&amp;re=now[x]=ls[1]+rs[1];    w[1]=ls[0]+rs[0];    if((w[0]=!!sl[x]+!!sr[x])&gt;1) re+=w[1];    return(re+=(ls[0]&gt;1)+(rs[0]&gt;1));}void bfs(){    s={rt};    for(int i=0;i&lt;(int)s.size();++i){        int x=s[i];        fa[sl[x]]=fa[sr[x]]=x;        if(sl[x]) s.push_back(sl[x]);        if(sr[x]) s.push_back(sr[x]);    }    for(int i=s.size();i;--i) ans+=calc(s[i-1]);}#define zg(l,r){\\    fa[s##l[f]=s##r[x]]=f;\\    fa[fa[s##r[x]=y]=x]=fy;}void change(int x,int y,bool is){    int f=fa[x],fy=fa[y];    if(is) zg(l,r)    else zg(r,l)    (sr[fy]==y?sr[fy]:sl[fy])=x;    for(int i=f,p=4;i!=y&amp;&amp;i&amp;&amp;--p;i=fa[i]){        ans-=now[i];        ans+=calc(i);    }    ans-=now[y]+now[x];    ans+=calc(y);ans+=calc(x);    for(int i=fy,p=3;i&amp;&amp;--p;i=fa[i]){        ans-=now[i];        ans+=calc(i);    }}void rotate(int x,ll &amp;now,int add){    for(;x!=rt;){        int is=sl[fa[x]]==x,e=is?t.pre(x,now):t.nxt(x,now),s=e?is?sr[e]:sl[e]:rt;        ll sp=p[s]+(s&lt;x);        if(sp&lt;=now+add){            change(x,s,is);            add-=sp-now;            now=sp;            if(s==rt) rt=x;        }else{            int to=is?sl[t.nxt(x,now+add)]:sr[t.pre(x,now+add)];            if(x!=to&amp;&amp;to) change(x,to,is);            break;        }    }    now+=add;}void buildC(){    for(int i=1;i&lt;=n;s.push_back(i++)){        for(;s.size()&amp;&amp;p[i]&gt;p[s.back()];s.pop_back()) sl[i]=s.back();        if(s.size()) sr[s.back()]=i;    }    rt=s[0];    for(int i=1;i&lt;(int)s.size();++i) sr[s[i-1]]=s[i];    bfs();}int main(){    fread(BuF,1,FSIZE,stdin);    read(n);    for(int i=1;i&lt;=n;++i) read(p[i]);    buildC();    t.build();    read(m);    for(int x,y;m--;){        read(x);read(y);        rotate(x,p[x],y);        t.add(x,y);        write(ans-now[rt]);    }    fwrite(WuF,1,OnF-WuF,stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Construction"]},{"title":"清华集训2017 榕树之心","url":"/post/Solution-P4228/","content":"题意\r\n给定  为根的  个结点有根树，定义一个长度为  的序列 \r\n合法当且仅当其所有前缀均为包含根的连通块，定义其终点为  的终点到  的路径上第二个结点。\r\n求每个点是否可能为合法的序列的终点。\r\n\r\n思路\r\n首先只考虑根的情况，我们发现我们可以取两个不同的子树，然后各加一个点，此时终点不变，但是两个子树的大小减一。\r\n于是我们只需考虑重儿子，因为只有重儿子的大小会超过子树大小的一半。\r\n设  为只考虑  的子树（根也假设为 ），可能的终点距离  的最小值。\r\n那么就有两种情况（设 \r\n为重儿子）：\r\n\r\n第一种表示重儿子做完之后，重儿子以外的结点能够把终点拉回 ，那么这个时候终点能不能在 \r\n就取决于子树的奇偶性，因为我们只能一对一对地消去结点。\r\n第二种表示不能拉回 ，那么这时其他所有结点显然都应该被用于将终点拉回\r\n。\r\n（ 表示  是没用的。）\r\n\r\n然后考虑将这个 DP 拓展到每一个结点上，注意到根到 \r\n的路径上这些结点都是没用的，因为它们必须顺次使用，而且在这些结点使用完之前，没有任何结点能将终点拉向\r\n，于是它们的唯一作用就是将终点拉向\r\n。\r\n于是我们可以先将它们使用掉，这样终点当前就位于 ，然后考虑其他所有的子树，它们的根显然不变，于是所有我们预处理的信息和上面的\r\nDP 式都仍然生效，这样只需维护出新的重儿子即可，只有两种可能，一是  本身的重儿子，二是 \r\n路径上的结点的重儿子（或次重儿子，如果下一个结点在重儿子上的话）。\r\n这些都容易维护。\r\nCODE\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=100010,FSIZE=1&lt;&lt;26;int w,tn,n,sz[N],f[N],s[N][2],ans[N];vector&lt;int&gt; t[N];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}void pre(int x,int fa){    sz[x]=1;    s[x][0]=s[x][1]=0;    for(int i:t[x])        if(i!=fa){            pre(i,x);            sz[x]+=sz[i];            if(sz[i]&gt;sz[s[x][0]]){                s[x][1]=s[x][0];                s[x][0]=i;            }else if(sz[i]&gt;sz[s[x][1]]) s[x][1]=i;        }}void dfs(int x,int fa){    for(int i:t[x])        if(i!=fa) dfs(i,x);    if(f[s[x][0]]+1&lt;=sz[x]-sz[s[x][0]]-1) f[x]=~sz[x]&amp;1;    else f[x]=f[s[x][0]]+1-(sz[x]-sz[s[x][0]]-1);}void get(int x,int fa,int up,int dp){    int mx=sz[s[x][0]]&gt;sz[up]?s[x][0]:up;    if(f[mx]+1&lt;=n-dp-sz[mx]) ans[x]=~(n-dp)&amp;1;    else ans[x]=0;    for(int i:t[x])        if(i!=fa) get(i,x,mx==i?sz[s[x][1]]&gt;sz[up]?s[x][1]:up:mx,dp+1);}void work(){    read(n);    for(int i=1;i&lt;=n;++i) t[i].clear();    for(int i=1,x,y;i&lt;n;++i){        read(x);read(y);        t[x].push_back(y);        t[y].push_back(x);    }    pre(1,0);    dfs(1,0);    if(w==3){        printf(\"%d\\n\",!f[1]);        return;    }    get(1,0,0,1);    for(int i=1;i&lt;=n;++i) printf(\"%d\",ans[i]);    puts(\"\");}int main(){    fread(BuF,1,FSIZE,stdin);    read(w);    f[0]=sz[0]=0xf0000000;    for(read(tn);tn--;work());    return(0);}\r\n","categories":["Solution"],"tags":["Dynamic Programming","Tree"]},{"title":"CTS2023 琪露诺的符卡交换","url":"/post/Solution-P9070/","content":"题意\r\n给定  矩阵 ，包含  各 \r\n个，求方案交换若干位置使得每个位置只交换一次，且交换后每行为  的排列。\r\n\r\n思路\r\n因为要求行是个排列，所以每行内部的顺序是可以任意调换的。\r\n不妨调换行内的顺序，使得每列为一个  的排列，注意这是不需要交换操作的。\r\n然后交换  与 ，这样每行就为一个  的排列。\r\n证明这样一定有解，我们每次需要在  行中找到  的排列，假设存在  行，其中值的种类数  满足 ，那么无解（Hall\r\n定理不成立），假定还剩下 \r\n列（并且每种值都有 \r\n个），根据鸽巢原理一定存在某种值的数量大于 ，矛盾。\r\nCODE\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=510,FSIZE=1&lt;&lt;26,INF=0x7f7f7f7f;int tn,n,cur[N],a[N],sze,d[N],w[N],p0[N],p1[N],is[N][N],c[N][N];struct{int n,t,v;}b[N*N];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}void _add(int x,int y,int z){    b[sze++]={a[x],y,z};    a[x]=sze-1;}void add(int x,int y,int z){    _add(x,y,z);    _add(y,x,0);}bool bfs(){    memset(w,127,sizeof(w));    for(int h=w[0]=0,t=d[0]=0;h&lt;=t;++h)        for(int i=cur[d[h]]=a[d[h]];~i;i=b[i].n)            if(b[i].v&amp;&amp;w[b[i].t]&gt;w[d[h]]+1)                w[d[++t]=b[i].t]=w[d[h]]+1;    return(w[n+n+1]&lt;INF);}int dfs(int x,int flow){    if(x==n+n+1) return(flow);    int used=0,aflow;    for(int &amp;i=cur[x];~i;i=b[i].n)        if(w[b[i].t]==w[x]+1&amp;&amp;b[i].v&amp;&amp;(aflow=dfs(b[i].t,min(b[i].v,flow)))){            b[i].v-=aflow;            b[i^1].v+=aflow;            if((used+=aflow)==flow) break;        }    return(used);}int dinic(){    int re=0;    for(;bfs();re+=dfs(0,INF));    return(re);}void work(){    memset(a,-1,sizeof(a));    sze=0;    read(n);    for(int i=1;i&lt;=n;++i){        add(0,i,0);        p0[i]=sze-2;        add(i+n,n+n+1,0);        p1[i]=sze-2;        for(int j=1,x;j&lt;=n;++j){            read(x);            add(i,x+n,1);            c[i][j]=sze-2;        }    }    for(int i=1;i&lt;=n;++i){        for(int j=1;j&lt;=n;++j){            b[p0[j]].v=1;            b[p0[j]^1].v=0;            b[p1[j]].v=1;            b[p1[j]^1].v=0;        }        dinic();        for(int j=1;j&lt;=n;++j)            for(int k=1;k&lt;=n;++k)                if(b[c[j][k]^1].v){                    is[j][i]=k;                    b[c[j][k]^1].v=0;                }    }    printf(\"%d\\n\",n*(n-1)&gt;&gt;1);    for(int i=1;i&lt;=n;++i)        for(int j=i+1;j&lt;=n;++j)            printf(\"%d %d %d %d\\n\",i,is[i][j],j,is[j][i]);}int main(){    fread(BuF,1,FSIZE,stdin);    for(read(tn);tn--;work());    return(0);}\r\n","categories":["Solution"],"tags":["Flow","Unknown"]},{"title":"斯坦纳树学习笔记","url":"/post/Steiner-Tree/","content":"先开题罢：\r\n\r\n旅行\r\n给定一个  个点 \r\n条边的带权图，求一个权值和最小的边集的使得  有  与  联通的权值和。\r\n无解输出 -1.\r\n\r\n\r\n非常清新的题面，状压也非常显然，但是搞生成树的时候自闭了。\r\n斯坦纳树\r\n首先就是要明白斯坦纳树是有一个平面上的（在 OI\r\n中没什么用的）定义的：\r\n对一个给定点集，求一个点集使得两个点集的并的联通代价（一般是两点距离，也可能是距离乘上权重等等乱七八糟的东西）。\r\n比如这样：\r\n\r\n但是，大部分时候我们并不关心这个定义。\r\n\r\n关于上面问题的解：\r\n在给定  个点的情形，最多将有\r\n\r\n个复接点（斯坦纳点）。过每一斯坦纳点，至多有三条边通过。若为三条边，则它们两两交成\r\n\r\n角；若为两条边，则此斯坦纳点必为某一已给定的点，且此两条边交成的角必大于或等于\r\n。\r\n——摘自 OI\r\nWiki\r\n\r\n图论上的斯坦纳树\r\n给定  个点  条边的带权图，与 \r\n个关键点，求一个权值和最小的边集的使得  有  与  联通的权值和。\r\n以下任何表述省略“在图中”。\r\n与引入的问题不能说是十分相似，只能说是完全就是\r\n\r\n首先，我们先定义一个 \r\n表示以  为根的包含了  这个集合中的关键点的最小生成树。\r\n然后，嗯，我们要定义一些转移：\r\n\r\n\r\n 其中\r\n 定义为  到  的最短路\r\n\r\n感性理解一下，第一条转移式就是把点集拼一起，第二条转移式就是把往树里加一条链。\r\n这个比较显然的答案不会小于答案。所以就是正确的，至于为什么不会大于我也不知道\r\n初始值把每个关键点自己生成自己设为  就行。\r\n转移显然最短路。\r\n原问题\r\n显然先把斯坦纳树生成出来，然后把在原题中合法的若干状态拼成全集就行。\r\nCODE\r\n#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define reg register#define uni unsigned#define ll long longusing namespace std;const int N=10010,FSIZE=1&lt;&lt;26,W=4,INF=0x3f3f3f3f;int n,m,k,r,a[N],b[N+N][3],last,g[N][2048],h,t,d[N&lt;&lt;3],map[N],ans=INF;bool leg[N];char BuF[FSIZE],*InF=BuF;int read(){    reg int x=0;    for(;47&gt;*InF||*InF&gt;58;++InF);    for(;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));    return(x);}void add(reg int x,reg int y,reg int w){    b[++last][0]=a[x];    b[a[x]=last][1]=y;    b[last][2]=w;}void change(reg int &amp;x,reg int &amp;y){    swap(map[x],map[y]);    swap(x,y);}void push(reg int nxt,reg int s){    if(!map[nxt]){        d[map[nxt]=++t]=nxt;        if(t&gt;h+1&amp;&amp;g[d[t-1]][s]&lt;g[d[t]][s]){            change(d[t],d[t-1]);        }    }else if(g[nxt][s]&lt;g[d[t]][s]){        change(d[map[nxt]],d[t]);    }}void spfa_PMF(int s){    for(;h&lt;=t;++h){        reg int &amp;hd=d[h];        for(reg int i=0,*zh=d+h+1,*tl=d+t;i&lt;W&amp;&amp;zh&lt;tl;++i,++zh,--tl){            if(g[hd][s]&gt;g[*zh][s]){                change(hd,*zh);            }            if(g[hd][s]&gt;g[*tl][s]){                change(hd,*tl);            }        }        for(reg int i=a[hd];i;i=b[i][0]){            reg int nxt=b[i][1],p=g[hd][s]+b[i][2];            if(g[nxt][s]&gt;p){                g[nxt][s]=p;                push(nxt,s);            }        }        map[hd]=0;    }}int main(){    fread(BuF,1,FSIZE,stdin);    n=read();m=read();    for(r=1&lt;&lt;(k=read());m;--m){        reg int x=read(),y=read(),w=read();        add(x,y,w);        add(y,x,w);    }    memset(g,63,sizeof(g));    for(reg int i=0;i&lt;k;g[read()][1&lt;&lt;i++]=0);    for(reg int i=1;i&lt;r;++i){        h=0;t=-1;        for(reg int j=1;j&lt;=n;++j){            for(reg int k=i&amp;(i-1);k;k=i&amp;(k-1)){                g[j][i]=min(g[j][i],g[j][k]+g[j][i^k]);            }            if(g[j][i]&lt;INF){                push(j,i);            }        }        spfa_pmf(i);    }    for(reg int i=0;i&lt;n;ans=min(ans,g[++i][r-1]));    printf(\"%d\",ans);    return(0);}\r\n","categories":["Note"],"tags":["Steiner Tree"]},{"title":"THUPC2023 D 种苹果","url":"/post/THUPC2023-D/","content":"不喜欢这道缝合题，但是写了很久。\r\n\r\n题意\r\n给一颗树，支持加点、边中加点、树链加、树链查询  的排名。\r\n。\r\n思路\r\n首先做教主的魔法，然后做无处储存。\r\n然后把两道题融合即可通过本题，随机撒点树链分块然后块内排序，查询时对整块块内二分，时间复杂度\r\n。\r\n可见本题只有蓝题难度。\r\n对于加点，分成若干情况讨论然后把链重新连一下即可。\r\n实现\r\n但是第一次写树链分块，所以写挂了。\r\n细节包括但不限于：\r\n\r\n深度是比较难维护的，所以求 LCA\r\n直接令一个点跳到根并标记路径，然后令另一个点去找标记，注意同在一条链上时要暴力判一下哪个比较浅（记得清空标记）。\r\n连链的时候按照 \r\n为一节拆开，最后保留一节小于 \r\n的（令重链长度不小于 ），自动保证复杂度正确，然后记得下放中间的链的信息。\r\n为了保证复杂度，对于散点需要维护一个下方最长链的长度，在向上找链的时候维护即可。\r\n对于边中间加点有四种情况：\r\n\r\n在链中间，这种情况先把链的信息下放下去，然后重连。\r\n在两条链的中间，因为链是下闭上开的，所以下放下方链的信息，然后重连下方链到上方链的顶部。\r\n在上方链的底部，直接连到上方链（这种情况当散点也行）。\r\n在散点，这个时候要判断下方最长链的长度加上方到链上的距离，够大就从底部连上来。\r\n\r\n注意边中间加点的时候，对于链信息需要提前手动下放，不然新点连好之后再下放信息会有问题。\r\n在点下加点要判断上方到链上的距离，维护一下结构。\r\n结点 \r\n是不在任何链中的，这个一定要注意。\r\n根据实现复杂度还会有若干细节（以上是我精简代码之后仅剩的）。\r\n\r\n关于常数\r\n我去除了大部分的运行用时，但保留了一小部分，好让评测机知道它评测的是\r\nN 根号 Log。\r\n这个做法应该不卡常，我第一遍调出来就\r\n3.7s，个人感觉询问分块然后重构的方法是比较卡常的，因为我赛后写了一份现在没过。\r\n\r\n写挂的时候发现一个卡常小寄巧，对于所有非根的点总是保留第一条链不连成链（无论任何情况都不连接），让上面的点连。\r\n然后就是对于暴力修改小于一定阈值使用插入排序。\r\n块长调小，跑的很快，2.5s 左右。\r\nCODE\r\n含少量注释。\r\n#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;random&gt;#include&lt;chrono&gt;#include&lt;algorithm&gt;using namespace std;const int N=400010,FSIZE=1&lt;&lt;24,B=280;int n,m,p[N],fa[N],up[N],in[N],dp[N],hs[N],path[N],tag[N],tmp[N];bool v[N];vector&lt;int&gt; t[N];vector&lt;pair&lt;int,int&gt;&gt; c[N];char BuF[FSIZE],*InF=BuF,WuF[FSIZE],*OnF=WuF;template&lt;typename T&gt;void read(T &amp;x){    bool f=0;    for(x=0;48&gt;*InF||*InF&gt;57;*InF++=='-'&amp;&amp;(f=1));    for(;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));    f&amp;&amp;(x=-x);}void write(int x){    char st[12]={},*c=st;    for(!x&amp;&amp;(*OnF++=48);x;x/=10) *++c=x%10^48;    for(;c!=st;*OnF++=*c--);    *OnF++='\\n';}void reset(int u){    // 下放链的信息，并删除这条链    c[u].clear();    if(int &amp;i=tag[u]){        for(int x=up[u];u!=x;u=fa[u]) p[u]+=i;        i=0;    }}void set(int x,int y){    // 将 x-&gt;y 连接成若干条链    for(tmp[tmp[0]=1]=x;x!=y;tmp[++tmp[0]]=x=fa[x])        if(x==in[x]) reset(x);    for(int *i=tmp+1,*j=i,*r=tmp+tmp[0];i&lt;r;i=j){        int *nxt=i+B;        if(nxt+B&gt;r) nxt=r;        for(;j&lt;nxt;++j){            up[*j]=*nxt;            c[in[*j]=*i].emplace_back(p[*j],*j);        }        sort(c[*i].begin(),c[*i].end());    }}int dfs(int x){    // 预处理初始撒点情况    int re=0;    for(int i:t[x]) if(i!=fa[x]){        fa[i]=x;        if(int tmp=dfs(i)){            if(re){                set(tmp,x);                v[x]=1;            }else re=tmp;        }        if(dp[i]&gt;dp[hs[x]]) hs[x]=i;    }    dp[x]=dp[hs[x]]+1;    return(!re&amp;&amp;v[x]?x:re);}pair&lt;int,int&gt; getup(int i){    // 获取到上方链的距离及编号，并维护向下最长链的长度    for(int x,dis=0;;++dis,i=x){        if(dp[i]&gt;dp[hs[x=fa[i]]]) dp[x]=dp[hs[x]=i]+1;        if(in[x]||x==1) return(make_pair(x,dis));    }}void add(int u,int w){    // 点下加点    fa[++n]=u;    p[n]=w;    auto m=getup(n);    if(m.second&gt;=B) set(n,m.first);}void add(int u,int v,int w){    // 边中加点    if(fa[u]==v) swap(u,v);    if(in[v]) reset(in[v]);    // 提前手动下放    fa[fa[v]=++n]=u;    p[n]=w;    if(in[v]&amp;&amp;in[v]!=in[u]) return(set(in[v],u));    // 在两条链中间    if(in[u]) return(set(u==in[u]?n:in[u],up[u]));    // 在链中间或底部    dp[n]=dp[hs[n]=v]+1;    auto m=getup(n);    if(m.second+dp[n]&gt;=B+B){        int x=n;        for(;hs[x];x=hs[x]);        set(x,m.first);    }}int check(int u,int v){    // 返回两结点中较浅的一个    int x=in[u];    for(;x!=v&amp;&amp;x!=u;x=fa[x]);    return(x==v?u:v);}int lca(int u,int v){    // 如名    int x=u,re=0;    for(;!up[x]&amp;&amp;x&gt;1;x=fa[x]) path[x]=1;    for(;!up[v]&amp;&amp;v;v=fa[v])        if(path[v]){            re=v;            break;        }    for(;!up[u]&amp;&amp;u&gt;1;u=fa[u]) path[u]=0;    if(re) return(re);    for(;x&gt;1;x=up[x]) path[in[x]]=x;    for(;v&gt;1;v=up[v])        if(path[in[v]]){            re=check(path[in[v]],v);            break;        }    for(;u&gt;1;u=up[u]) path[in[u]]=0;    return(re?re:1);}void modify2(int u,int v,int w){    // 对链内（或散点）暴力修改    int b=in[u],sz=0;    for(;u!=v;u=fa[u],++sz) p[u]+=w;    if(b){        for(auto &amp;x:c[b]) x.first=p[x.second];        if(sz&lt;8)            for(auto i=c[b].begin()+1;i&lt;c[b].end();++i)                for(auto j=i;j&gt;c[b].begin()&amp;&amp;j[-1]&gt;*j;--j) swap(j[-1],*j);        else sort(c[b].begin(),c[b].end());    }}void modify1(int u,int x,int w){    // 修改祖先后代链    for(;!up[u]&amp;&amp;u!=x;u=fa[u]) modify2(u,fa[u],w);    for(;in[u]!=in[x];u=up[u])        if(in[u]==u) tag[u]+=w;        else modify2(u,up[u],w);    modify2(u,x,w);}void modify(int u,int v,int w){    // 如名    int l=lca(u,v);    modify1(u,l,w);    modify1(v,l,w);    modify2(l,fa[l],w);}int query2(int u,int x,int w){    // 对链内（或散点）暴力询问    int re=0;    for(w-=tag[in[u]];u!=x;u=fa[u]) re+=p[u]&gt;=w;    return(re);}int query1(int u,int x,int w){    // 询问祖先后代链    int re=0;    for(;!up[u]&amp;&amp;u!=x;u=fa[u]) re+=p[u]&gt;=w;    for(;in[u]!=in[x];u=up[u])        if(u==in[u])            re+=c[u].end()-lower_bound(c[u].begin(),c[u].end(),make_pair(w-tag[u],0));        else re+=query2(u,up[u],w);    return(query2(u,x,w)+re);}int query(int u,int v,int w){    // 如名    int l=lca(u,v),re=p[l]&gt;=w-tag[in[l]];    re+=query1(u,l,w);    re+=query1(v,l,w);    return(re);}int main(){    fread(BuF,1,FSIZE,stdin);    read(n);read(m);    for(int i=1;i&lt;=n;++i) read(p[i]);    for(int i=1,x,y;i&lt;n;++i){        read(x);read(y);        t[x].push_back(y);        t[y].push_back(x);    }    mt19937 rnd(chrono::steady_clock().now().time_since_epoch().count());    for(int i=v[1]=1;i&lt;=n;i+=B) v[rnd()%n+1]=1;    set(dfs(1),1);    // 注意手动连接最后一条传上来的链    for(int i=0,o,x,y,w,lastans=0;i&lt;m;++i){        read(o);read(x);read(y);        x^=lastans;        y^=lastans;        if(o!=2){            read(w);            w^=lastans;            switch(o){            case 1:add(x,y,w);break;            case 3:modify(x,y,w);break;            case 4:write(lastans=query(x,y,w));            }        }else add(x,y);    }    fwrite(WuF,1,OnF-WuF,stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Data Structure","Tree","Sqrt Algorithm"]},{"title":"上下界网络流学习笔记","url":"/post/ULB-Flow/","content":"2021/1/23 upd:\r\n复习的时候回来看，然后就开始改改改……修了各种锅，加了点没用的东西。\r\n2021/7/7 upd: 修正表达。\r\n\r\n其实这篇东西的内容与参考的博客写的差不多，只是加上了个人的理解与几个图。\r\n在学习之前先来看一道例题。\r\n\r\n集训队互测2013 供电网络\r\n给出一个流网络，对于一条流量为  的边费用为  ，每一条边\r\n 有一个最小流量  和最大流量 ，每一个点初始有一定流量 （可能为负），同时每一个点可以花\r\n 费用补充流量、 减少流量，求使每个点流量为 0\r\n且每条边的流量满足的上下界的最小费用。\r\n\r\n\r\n\r\n首先来看题，我们发现里面充满着网络流基操：建源汇、拆费用边、最小流量……\r\n非常完美的网络流 N 合一板子题。\r\n然我并不会上下界……\r\n无源汇上下界可行流\r\n首先我们注意到“无源汇”，这说明这玩意并没有源点或汇点。\r\n那么流量从哪来？\r\n既然没有源节点 生产者 和汇结点 消费者\r\n，流量当然是凭空产生的啦！虽然听起来非常草率，但这个玩意确实是这么定义的，只要满足流量守恒就可以了。其效果约等于一堆流量在流网络里不断转圈。\r\n那么我们不产生可不可以\r\n现在的问题在于，对于一个有下界的边，它必须要流其下界的流量，这令人感觉非常不好处理。\r\n优先增广没到下界的边\r\n于是反过来想，对于某条边，反正都要流这么多流了，那么不如直接让它流这么多流，起点一定是要少这么多流量的，而终点也一定是要多这么多流量的。于是我们新建一个超源，往这条边的终点建一条下界容量的边，表示这个点一定会有这么多流量。具体怎么来的并不重要，反正不管是偷的抢的捡的就有这么多了；同时这条边的起点向超汇连一条下界容量边，表示这个点必须要有这么多流量。\r\n现在剩下一个问题：多/少的流量怎么办？\r\n当然是使用剩下的边的容量流过去啦！\r\n于是直接从超源到超汇跑一边最大流，如果每一个点的请求都能被满足（每一条从超源发出的边都满流），那么这个流网络就是有可行流的。\r\n当然，实际处理时一般是先把所有边的两边直接加减处理之后再加边的，如果某个点为正数，就表示它多了流量，要从源点接过来并经由别的某些点送到汇点去。如果为负，表示它要从别的点那里领流量并补到汇点去。\r\n讲的有点多，不如上一张图：\r\ngraph LR     1((1)) --3/5--&gt; 2((2))    2((2)) --3/4--&gt; 3((3))    3((3)) --1/3--&gt; 1((1))\r\n现在有这样一个上下界流网络，我们一眼可以看出一个可行流是每条边3流量。\r\n现在要对这个图进行一些处理：\r\n对于结点1，流入1流量，流出3流量，所以往 TT 连出一条容量为2的边。\r\n对于结点2，流入3流量，流出3流量，所以不与 SS 或 TT 连边。\r\n对于结点3，流入3流量，流出1流量，所以从 SS 连入一条容量为2的边。\r\n然后对于原图中的边，显然上界减去下界还剩下一些容量，所以还要连起来。\r\n所以图长这样：\r\ngraph LR    0((SS)) --2--&gt; 3((3))    1((1)) --2--&gt; 2((2))    2((2)) --1--&gt; 3((3))    3((3)) --2--&gt; 1((1))    1((1)) --2--&gt; 4((TT))\r\n经过一波构造，我们偷税的发现，令人烦躁的流下界全都去吃梁非凡套餐了。\r\n然后跑一边最大流，发现从 SS\r\n连出的边全部满流了，于是说明这玩意有一个可行流。\r\n\r\nQ：为什么不检查 TT 跑满没有？\r\nA：因为显然 SS 连出的容量和 TT 连入的容量是一样的。\r\n好像这个制杖问题只有我会问\r\n\r\n如果要输出方案直接输出原图中的边的流量即可，如果要费用流也显然可以直接套上去。\r\n然后我们发现这并不能解决一开始的问题，因为我们在建图时会有一对源汇。\r\n有源汇上下界网络流\r\n可行流\r\n上面已经说了，无源汇上下界可行流的效果约等于一堆流量在流网络里不断转圈。但这里我们有一个源汇，这俩家伙显然不满足流量守恒，也就是流量在流网络里并不能乱跑，所以就不能直接凭空产生流量。\r\n那么我们从汇点向源点连一条上界无穷下界为0的边，就可以让到了汇点的流量再回到源点，这样就可以让源点与汇点也满足流量守恒。\r\n让流量获得解放，让它们自由的飞翔\r\n于是我们就把有源汇转换成了无源汇，因为网络流中源汇点的作用就是它们不满足流量守恒\r\n生产者与消费者\r\n。而这里我们让这两个家伙满足了流量守恒，于是这俩家伙就被架空了，失去了不满足流量守恒的权力与普通点无异，我们就可以再建一个真正的超源汇来搞定上下界了。\r\n注意：\r\n因为现在的假源汇点跟普通点是一样的，所以不要因为它们曾经的地位就忘了让超源汇向它们连边了。\r\n稍微弄一幅图示意一下：\r\ngraph LR    subgraph 新图        SS((SS)) --1--&gt; 12((1))        SS((SS)) --1--&gt; 22((2))        SS((SS)) --2--&gt; T2((T))        T2((T)) --inf--&gt; S2((S))        S2((S)) --2--&gt; 12((1))        S2((S)) --1--&gt; 22((2))        12((1)) --2--&gt; 22((2))        22((2)) --3--&gt; T2((T))        S2((S)) --4--&gt; TT((TT))    end    subgraph 原图        S((S)) --3/5--&gt; 1((1))        S((S)) --1/2--&gt; 2((2))        1((1)) --2/4--&gt; 2((2))        2((2)) --2/5--&gt; T((T))    end\r\n我们发现 SS 连出来的边是能跑满的，于是原图有一个可行流。\r\n题解\r\n到这里我们就可以解决开头的那道题了，我们先让假源到每个点那里兜售流量，再让假汇到每个点那里低价回收流量\r\n低到负价\r\n，这样看起来我们把源点直接连无穷边连到了汇点，不过因为这两家伙是假的，所以并不影响正确性。接下来再把每条边拆费用，然后按刚刚的方法搞有源汇上下界可行流板子即可，记得用费用流。\r\n废话\r\n最大流\r\n注意到这个被丢进有源汇里了，因为如果没有源汇的话你还打算统计在流网络里有多少流量在转圈不成……\r\n\r\n关于这玩意为什么不能是无源汇的可以非常简单快速不要脑子的用反正法证明：“反正也不考。”\r\n\r\n首先先按可行流的方法跑一边，然后现在就是要榨干剩下的边的流量。\r\n那么我们把从 T 到 S\r\n的无穷边删掉（如果不删掉就会把这条边上加载的流量从反向边上全推回去， SS\r\n和 TT 的边可以不删因为不会联通 S 和 T ），从 S 到 T\r\n跑一遍最大流，再加上原来的可行流即可。\r\n最小流\r\n其实跟上下界最大流差不多，只不过做完可行流之后我们的任务变成把尽可能多的流量推回去。\r\n于是我们照样的把从 T 到 S\r\n的无穷边删掉（如果不删掉就会把无穷的流量直接推到源点去，然后就 GG\r\n了），然后从 T 到 S\r\n跑一遍最大流（直接在残量网络上跑，不需要建反向图什么乱七八糟的东西），从可行流上减掉即可。\r\n费用流\r\n把预加载的流量的费用算出来，然后正常跑费用流。\r\n显然 SS 和 TT 的边是没有费用的。\r\n这一段水极了\r\n习题\r\n先是模板题：无源汇可行流 、 有源汇最大流 、 有源汇最小流 。\r\nZOJ3229.\r\nShoot the Bullet （有源汇最大流）\r\nBZOJ3698.\r\nXW的难题 （有源汇最大流）\r\nBZOJ2502.\r\n清理雪道 （有源汇最小流）\r\nSNOI2019 通信 （费用流\r\n，可以不用上下界）\r\nBJWC2018 Kakuro （费用流\r\n，可以不用上下界）\r\n这里的 BZOJ 链接指向某个离线题库。\r\n要交的话就不用科普去哪了吧\r\n题解什么的咕咕咕。 才不是因为没做\r\n不幸的是开头那道题并没有哪个公开OJ收录（至少本蒟蒻没找着），只能在某个校内OJ交。\r\n更不幸的是这玩意好像真的没人考以至于我找不到什么题（捂脸）……\r\n参考博客\r\nhttps://blog.csdn.net/corsica6/article/details/81488993\r\nhttps://blog.csdn.net/Clove_unique/article/details/54884437\r\nhttps://blog.csdn.net/HiChocolate/article/details/85239805\r\n","categories":["Note"],"tags":["Flow","ULB Flow"]},{"title":"USACO 2019OPEN Valleys P","url":"/post/USACO19OPEN-Valleys-P/","content":"题意\r\n给定 \r\n矩阵，求所有四联通区域的大小和、满足其中每个元素都小于所有其四联通的、相邻的、不在该区域的元素，并且该区域以外的矩阵是八联通的（包括\r\n 矩阵以外的超平面）。\r\n\r\n思路\r\n首先小于的条件可以通过由小到大加点解决，这样问题在于加点之后求两个区域内部是否联通。\r\n其实看到八联通要包括矩阵以外的超平面就应该想到平面图欧拉定理的\r\n然鹅我并没有。\r\n这样我们直接使用并查集，维护点数，边数，以及联通快内部形成的小区域的数量，通过\r\n\r\n即可解出剩下区域的数量，若合法应当为 。\r\nCODE\r\n#include&lt;tuple&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define get(x,y) ((x-1)*n+y)using namespace std;using ll=long long;const int N=760,M=1000010,FSIZE=1&lt;&lt;26,fx[4][2]={{1,0},{-1,0},{0,1},{0,-1}};int n,s[N*N][4];ll ans;pair&lt;int,int&gt; e[M];bool a[N][N];char BuF[FSIZE],*InF=BuF;template&lt;typename T&gt;void read(T &amp;x){    for(;48&gt;*InF||*InF&gt;57;++InF);    for(x=0;47&lt;*InF&amp;&amp;*InF&lt;58;x=x*10+(*InF++^48));}int root(int x){    if(s[x][0]){        int r=s[x][0]=root(s[x][0]);        s[r][1]+=s[x][1];        s[r][2]+=s[x][2];        s[r][3]+=s[x][3];        s[x][1]=s[x][2]=s[x][3]=0;        return(s[x][0]);    }    return(x);}void merge(int x,int y){    if((x=root(x))!=(y=root(y))){        s[x][0]=y;        s[y][1]+=s[x][1];        s[y][2]+=s[x][2];        s[y][3]+=s[x][3];        s[x][1]=s[x][2]=s[x][3]=0;    }}int main(){    freopen(\"valleys.in\",\"r\",stdin);    freopen(\"valleys.out\",\"w\",stdout);    fread(BuF,1,FSIZE,stdin);    read(n);    for(int i=1;i&lt;=n;++i)        for(int j=1,x;j&lt;=n;++j){            read(x);            e[x]=make_pair(i,j);        }    for(int i=1;i&lt;M;++i)        if(e[i].first){            int x=e[i].first,y=e[i].second,t=get(x,y);            a[x][y]=1;            s[t][1]=1;            s[t][2]=a[x-1][y]+a[x+1][y]+a[x][y-1]+a[x][y+1];            s[t][3]=(a[x-1][y]&amp;&amp;a[x][y-1]&amp;&amp;a[x-1][y-1])+                    (a[x-1][y]&amp;&amp;a[x][y+1]&amp;&amp;a[x-1][y+1])+                    (a[x+1][y]&amp;&amp;a[x][y-1]&amp;&amp;a[x+1][y-1])+                    (a[x+1][y]&amp;&amp;a[x][y+1]&amp;&amp;a[x+1][y+1]);            if(a[x-1][y]) merge(get(x-1,y),t);            if(a[x][y-1]) merge(get(x,y-1),t);            if(a[x+1][y]) merge(get(x+1,y),t);            if(a[x][y+1]) merge(get(x,y+1),t);            if(2+s[t][2]-s[t][3]-s[t][1]==1) ans+=s[t][1];        }    printf(\"%lld\\n\",ans);    fclose(stdin);    fclose(stdout);    return(0);}\r\n","categories":["Solution"],"tags":["Set Union","Planar"]},{"title":"USACO22OPEN Up Down SubsequenceP","url":"/post/USACO22OPEN-Up-Down-Subsequence-P/","content":"\r\n","categories":["Solution"],"tags":["Data Structure","Dynamic Progragmming"]},{"title":"WC2022","url":"/post/WinterCamp2022/","content":"D1\r\n上午\r\n第一课堂：\r\n\r\n旋转卡壳。\r\n有一定计算几何技巧非常简单。\r\n\r\n第二课堂：《计算几何初步》\r\n\r\n第一课堂：\r\n也可以随机化。\r\n评论区：\r\n\r\n那个直接跑随机化也就是模拟退火卡掉了吗？\r\n“随机化没有前途”。\r\n\r\n\r\n第一课堂：\r\n大家应该都做过很多线性规划的题目了。\r\n我：题面在哪里？\r\n\r\n警惕音游势力入侵：\r\n\r\n为什么出现了奇怪的插入\r\n\r\n现场出现大型 mopemope 交流。\r\n\r\n可是这不是来帮我做题的吗？为什么跟 AI 扯上了大把关系啊喂。\r\n下午\r\n这不是工程级的东西，听来干嘛？\r\n真香。\r\n评论区一片欢腾。\r\n\r\nnew 一个厕所。\r\n114514℃\r\n99 bad 1 good\r\n\r\n我觉得我唯一能听懂的就是这个了。\r\nD2\r\n在划水出题，木有认真听。\r\n《那年 IOI 在伊朗》\r\n《FST 这种事情呢》\r\nD3\r\n上午\r\n金句频出。\r\n《连不上》\r\n生活不易，明扬叹气。\r\n《怎么这么多聊天区》《同场竞技》《优势在我》\r\n《高人的锦囊》\r\n《大家都已经长大了，都可以自己渲染 了。》\r\n《我是椰树牌椰汁的粉丝，我很会排版》\r\n\r\n椰汁\r\n\r\n《连根拔起并从世界上消失》\r\n《毫无波兰》 严重怀疑出现了 P 社玩家。\r\n《拉 tex》\r\n《野蛮人》《找代码》\r\n《很大很大》《椰树牌代码》\r\n《一个题可以搬到五个地方》《它好就好在吧，它就很好》《它好就好在，大家可以多做几遍，也没关系。》\r\n《差点有人过了，我大受震撼》\r\n《这什么锤子》\r\n《我超会讲的啦》\r\n《下一个选手，几乎是 114514 分钟过的》《114514\r\n是啥？不是，我开玩笑的，我只是泛指一个数很大》\r\n《优势在我》\r\n我也只是泛指一个数很大。\r\n《Benq 看了震惊一整年》\r\n《luogu 上能有加强版？》\r\n《luogu 这么有实力的吗？》\r\n《事情很难理解，但事情就是这样，小编也很惊讶》\r\n《相当于奶酪把老鼠吃了》由于题目过于生草引起广泛不适，警方已介入调查。\r\n奶酪的故事：《从降生到逝世》\r\n《很蓝的啦》\r\n《哦，现在快一点了，明天九点还要考试呢。我上个大学这么多事呢》没事，明天还有二十三小时才到呢。\r\n《奶酪可能长腿，但绝不会变质》\r\n《学会自己播放》\r\n《哇好恐怖，它卡住了》\r\n《苹果就这》\r\n《苹果太好了，所以永不重启》\r\n《没关系啊，优势在我，它现在不卡了。卡老师，不卡了》\r\n下午\r\n《1919810 太小了》\r\n然鹅都在认真对拍，并没有听。\r\nD4\r\n上午\r\n全 E 文的带修 PPT 警告。\r\n一群人刷起了 DMY，虽然 DMY\r\n超会讲也超会做的但真的不至于。\r\nDMY：IOI？优势在我。\r\n¯\\_(ツ)_/¯\r\n《一个村里小孩》\r\n《另一个村里小孩》\r\nReady For Even Year Bull****\r\n我们机房的某位大佬因为全文回复上文被切了。\r\n\r\n相信我，非常惊恐：\r\n\r\n非常惊恐\r\n\r\n什么叫真正的人机交互啊！\r\n《OK，我给大家讲一下怎么套数据》\r\n\r\n《ASCII 码，这就是一个 ASCII 的转换，我出的》\r\n《我就是想坑人》\r\n《MooMOoMoOMOOMoo！》\r\n《Rage Tree！》无端联想：《GOODGAGE》\r\n下午\r\n《为什么可以随便指定一条出边，因为指定一条出边是可以做的》\r\n《洛谷上怎么可能有加强版》\r\n《洛谷这么有实力的吗》\r\n《洛谷确实、很有实力》\r\n《std的复杂度是 n^{2d}，我的复杂度是n^{d+1}，是不是要优一点》\r\n这位的 LaTeX 渲染不大行啊\r\n优势在我.jpg\r\n《非常神秘》\r\n《神秘做法》\r\n《线性》《这不重要》\r\n《再拖半个小时行不行啊》\r\n《优势在您》\r\n《录屏不能看的吗》《这么神秘》\r\n（录屏引发讨论）《发生啥了》\r\n!!! note 可能引起不适的 WC 绘板 \r\nD5\r\nT1：\r\n一上来发现很不可做，所以直接跳过，后面回来发现暴力没时间打了。\r\n后面出考场才发现两个无限包是送分的，写了就能水金了。\r\nT2：\r\n一上来看错题意，发现过不去样例，然后又看错题意（区间内的数在区间内第几大减去位置的绝对值）甚至把样例过了，然后发现可以用只增不删的回滚莫队套线段树什么的。\r\n后面搞完 T3 回来看懂题面后码了一个 \r\n的莫队套线段树之后卡了卡常就跑了。\r\n确实没想到只删不增可以做到均摊线性，要不是有时间写回滚的。\r\nT3：\r\n发现前两题都不可做所以决定搞\r\nT3，一上来先手玩了一下，发现只要搞出一两个金银后面就很好猜。\r\n然后决定先写一发按照当前信息筛选的玩意，然后又手玩了一小会，把这个东西加几个随机拿去交互，直接取得了\r\n80pts 的好成绩。\r\n然后根据我手玩的经验又写了一个信息不足（筛选出的词过多）时，从一个特殊的词库里面按照尽可能的不重复的原则随机取词，经测试，筛选出词数判为过大的阈值甚至可以调至\r\n25 是最优的。\r\n然后就可以拿到 87pts 左右，后面评测机很好心的送了我\r\n88pts。当然没什么用\r\n《我今天讲的跟你们明天的比赛没有关系》\r\n最后又跟去年一样打银了，时间规划确实不太合理（写完 T3\r\n已经过了一半的时间），而且读题能力拉跨。就跟读谱能力一样低下\r\n","categories":["Record"],"tags":["Log","WC"]},{"title":"令人无法理解的有意义内容","url":"/post/cant-understand/","content":"由于准备补数学，所以准备找个垃圾桶把令人无法理解的有意义内容记一下。\r\nMin-Max 容斥\r\n\r\n找到了一个非常好证明，考虑 \r\n从大到小排序之后是 ，那么显然左边是 ，接下来证明右边是 ：\r\n考虑对于  的值分讨贡献：\r\n\r\n：此时右边是 。\r\n：此时  包含  中的任意个与一个 ，那么总的集合数量为 \r\n个，由单位根反演得其中大小为奇数与偶数的均为  个，所以总和为 。\r\n\r\n以上证明 \r\n对换，然后从小到大排序得到： \r\n扩展 Min-Max 容斥\r\n不会。\r\nHAOI2015 按位或\r\n显然把最大值转成最小值，然后考虑集合怎么整，由于我们求的是 ，所以集合里只要选上一个，于是考虑算所有与当前集合\r\n 有交集的集合 \r\n的概率总和。但是这并不好算，考虑反过来求没有交集的  的概率。这些  满足是 \r\n的子集，那么得到一个卷积的柿子：  用 FWT 算出 ，然后套进\r\nMin-Max 容斥的柿子里：  使用了经典结论 \r\n概率成立的事件期望成立次数为 。\r\n","categories":["Log"],"tags":["Math"]},{"title":"纯循环 DFS","url":"/post/loop-DFS/","content":"在做 P5384\r\nCnoi2019雪松果树 的时候无聊玩出来的无用科技。\r\n众所周知，有一类题目会通过给出  的方式来给出一棵树，并且有  这样的很好的性质。\r\n所以不妨考虑如何不使用递归或栈来 DFS 这样的一棵树。\r\n\r\n首先我们既然需要 DFS 而非 BFS，那么基本都是需要 DFS\r\n序的，所以我们先求出这个。\r\n考虑这样的情况：\r\ngraph TD    1((1)) --&gt; 2((2))    1 --&gt; 3((3))    1 --&gt; 4((4))    2 --&gt; 5{...}    3 --&gt; 6{...}    4 --&gt; 7{...}\r\n假定我们按照编号从小到大的顺序遍历三个点，那么  且 ，原因显然。\r\n那么我们在读入  之后倒序遍历\r\n 个点，每个点向父亲贡献 ，同时如果父亲 \r\n非零则说明其已经“遍历”了一些儿子，此时我们的 DFS 序应该是父亲的 DFS\r\n序加上其当前 ，我们将这个值先存在  里面。\r\n然后再顺序扫一遍，然后将 \r\n设为 ，然后每个点的 DFS\r\n序加上其父亲的 DFS 序即可，并将每个 DFS 序对应的结点编号记做 。\r\nDFS 这棵树按照 \r\n的顺序遍历即可。\r\nfor(int i=2;i&lt;=n;++i){    read(fa[i]);    dp[i]=dp[fa[i]]+1;}for(int i=n;i&gt;1;--i){    dfn[i]=sz[fa[i]]+1;    sz[fa[i]]+=++sz[i];}++sz[i];for(int i=dfn[1]=1;i&lt;=n;++i)    rk[dfn[i]+=dfn[fa[i]]]=i;// 然后 DFS 一遍for(int i=1;i&lt;=n;++i){    int x=rk[i];    // ...}\r\n树链剖分\r\n那么我们考虑支持一下最常见的应用。\r\n树剖的话，那么变化就是我们要将某个儿子的 DFS 序减小，然后将一些儿子的\r\nDFS 序增大。\r\n显然这个被减小的 DFS 序的结点编号必须大于这个重儿子。\r\n所以也很显然：\r\nfor(int i=2;i&lt;=n;++i){    read(fa[i]);    dp[i]=dp[fa[i]]+1;}for(int i=n;i&gt;1;--i){    dfn[i]=sz[fa[i]]+1;    sz[fa[i]]+=++sz[i];    if(sz[hs[fa[i]]]&lt;sz[i]) hs[fa[i]]=i;  // 更新重儿子}++sz[i];for(int i=dfn[1]=1;i&lt;=n;++i){    if(i!=hs[fa[i]]){        dfn[i]+=dfn[fa[i]];  // 不是重儿子        if(i&gt;hs[fa[i]]) dfn[i]+=sz[hs[fa[i]]];  // DFS 序增大        tp[i]=i;    }else{        dfn[i]=dfn[fa[i]]+1;  // 是重儿子        tp[i]=tp[fa[i]];    }    rk[dfn[i]]=i;}\r\n","categories":["Note"],"tags":["Tree","Unknown"]},{"title":"我与 rprmq2","url":"/post/rprmq2-story/","content":"写下标题之后颇有些奇异的感觉，大抵是曾读完过《我与地坛》的缘故。\r\n固然文字大抵是自由的，但是我仍深深地觉得亵渎，而没有资格道歉。\r\n故事也并不特别，只是快退役了发现自己仍没有故事，于是容易伤感。\r\n那又能怎么办呢？还是写些的好，毕竟那之前是回忆，那之后是追寻。\r\n不安河水\r\n2022.03.15\r\n省选模拟，不知道哪个凉心出题人把 rprmq2 搬到了模拟赛里，标题是\r\nMeasure。\r\n当天晚上讲题 口胡 的是 Alpha1022。\r\n做法非常容易懂，大概晚上九点我开始写，写到十点的时候说附近突发疫情，要全校核酸，于是高一和高二的学长就回班了（我们是“来”集训的）。\r\n然后说人很多可能要搞到凌晨两三点。\r\n已经保送的 DYP\r\n此时从机房门口跑跳路过（去隔壁机房），并使用一种活泼的语气吟唱：“熬夜熬夜、通宵通宵。”\r\n不过实际上并没有很久，我写到大概十一点多的时候下去排队，没到零点就做完回去睡觉了。\r\n2022.03.16\r\n早上 09:43:45 交了一发 TLE60，噩梦开始。\r\n60pts 对应 ，然而极限数据是 ，也就是大约要让常数变为原先的\r\n。\r\n\r\n11:48:53 TLE70。\r\n20:39:18 TLE80。\r\n\r\n之后没甚么新的进展，于是把题解写了一下。\r\n2022.03.18\r\n17 号在打模拟赛，没写。\r\n18 号 16:47:30 的时候搞到了 90pts，但是首杀已经被 Cotton 抢了\r\nqwq。\r\n而且 90pts 还是中午问了 Cotton 并有效地优化了四分树的结果。\r\n2022.03.19\r\n自闭了，不会啊。\r\n然后连交了几发发现除了 OJ 的第一线程都过了，评测机差距巨大。\r\n但是喜提最劣解：\r\n\r\n从上到下分别是：lxl, std, cotton,\r\n以及我的两发\r\n\r\n2022.03.20\r\n过了 CF 的版本。\r\n省选\r\n于是伏笔了，疫情专挑 CCF 下手，由于我很烂就滚了没有省选打。\r\n那年高二都炸了，只有 FK 一个 B 和 RHX 一个 C。\r\nNOI\r\nFK 被 deque 卡了 Cu，RHX Ag。\r\n于是我开始频繁地上 cppreference，以及频繁地普及语法知识。\r\n之后，DYP 毕业了，高二的退役了，机房里少了好多人。\r\n造梦的人\r\n2023/3/27\r\n又是省选集训的时候。\r\n就莫名又想起这题，我测了测发现我跑  需要 25s，感觉好像有点希望。\r\n花了一上午最终是没有太多进展，不过我一年前写的代码确实有个地方写的太烂了。\r\n省选\r\n今年 _LHF_ 和 MoQZ A 队，JRZ B 队。\r\n如许多许多个省选一样，又有很多人离开了机房。\r\n2023/04/27\r\n跟本文标题没甚么关系，想起了一道关于推箱子的题目，在 OJ\r\n上搜寻了一个小时之后，最后使用 Sublime Text 在所有代码里搜索\r\n#. 得到了这题。\r\n是 2022/8/15 的题目，英文名\r\nsokoban，一直很有印象。那一天晚上讲题之前我跟小鱼玩了很久这题，标算是\r\n188000 多，我们做到了 256736。\r\n我花了两三天优化了那时的答案，现在是 270837 了。\r\n但是小鱼退役了，我左边的和左边的左边的位置上如今空无一人。\r\n仅仅半年多的时间，却恍若隔世。\r\n梦将醒，而我将离开伊甸。\r\n2023/6/11\r\n省队集训开始了，当然跟我没甚么关系。\r\n我回到 rprmq2，抱着一种不可名的感伤。\r\n然后我发现洛谷的机子相比于机房的机子慢了太多，本来想继续搁置的，但是毕竟已经开始。\r\n这几天的状态十分恍惚，毕竟卡常是一种如同《水星记》的情感。\r\n\r\n咫尺远近却无法靠近的那个人\r\n\r\n2023/6/14\r\n\r\n要怎么探寻 要多么幸运\r\n才能让你发觉你并不孤寂\r\n\r\n别说再见\r\n那天这个文件就已经建好了，但是因为各种原因总是没有动笔，便一直拖到了现在。\r\n似乎有的万千想法，如今能表达的唯余沉默。\r\n\r\n也许有一天我们 终究会面对分离\r\n\r\n那之后，希望我还能记得。\r\n\r\n真的忘了 你的名字\r\n是在哪座 寂静星石\r\n一直还有 你的样子\r\n被保留\r\n\r\n而我会被记得吗？\r\n\r\n我不想 让自己\r\n变成一个 矫情的傻子\r\n可是啊 我已经\r\n是了\r\n\r\n","categories":["Log"],"tags":["Record"]}]